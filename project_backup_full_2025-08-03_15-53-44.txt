====================================================================
FILE: .\.gitignore
====================================================================
/cli/build/
/build/



====================================================================
FILE: .\README.md
====================================================================
# Geministrator

**An AI-powered development assistant built on a team of collaborative agents.**

---

## ü§ñ Key Capabilities

- **Autonomous Workflows**: Deconstruct high-level tasks (e.g., "add user authentication") into a
  detailed, multi-step execution plan.
- **Agent-Based Architecture**: A council of specialized AI agents (Architect, Researcher,
  Antagonist) collaborate to plan, execute, and self-correct development tasks.
- **Intelligent Task Triage**: Automatically determines which specialists are needed for a given
  task, conserving resources and tokens for simple requests.
- **Persistent & Resumable Sessions**: Workflows are saved automatically. If a session is paused,
  fails, or requires user input, it can be resumed seamlessly.
- **Git Integration**: Automatically creates feature branches, commits work-in-progress, and
  integrates completed tasks back into the main branch.
- **Configurable & Malleable**: Agent behavior is defined in external JSON, allowing you to
  customize their core instructions without recompiling.
- **Dual Authentication**: Supports both Google Cloud's Application Default Credentials (ADC) for
  potential free-tier access and traditional API keys.
- **Free-Tier Mode**: Can be configured to exclusively use free-tier models and ADC authentication
  to avoid unexpected costs.

---

## üèóÔ∏è Architecture: The Council of Agents

Geministrator operates not as a single monolithic AI, but as a team of specialists with distinct
roles, managed by a central Orchestrator. This approach allows for more robust and nuanced
problem-solving.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Orchestrator   ‚îÇ ‚Üê You interact here. Manages the master plan.
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ Deploys agents based on a triage assessment
         ‚îÇ
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 F‚îÇ      Manager     ‚îÇ ‚Üê Executes the step-by-step workflow for a single task
 E‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 A‚îÇ    Architect     ‚îÇ ‚Üê Analyzes existing code to provide context
 T‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 U‚îÇ    Researcher    ‚îÇ ‚Üê Scours the web for best practices and documentation
 R‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 E‚îÇ     Designer     ‚îÇ ‚Üê Creates specifications and updates changelogs
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 B‚îÇ    Antagonist    ‚îÇ ‚Üê Critiques plans to find flaws before execution
 R‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 A‚îÇ   Tech Support   ‚îÇ ‚Üê Analyzes merge conflicts and other technical failures
 N‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 C         ‚îÇ
 H         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ExecutionAdapter ‚îÇ ‚Üê Interacts with the shell, file system, and Git
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üöÄ Getting Started

### Prerequisites

* **Java 21+**: Ensure a JDK is installed and the `JAVA_HOME` environment variable is set.
* **(Optional) Google Cloud SDK**: For ADC authentication (recommended), install and configure
  `gcloud`. Run `gcloud auth application-default login` to set up your credentials.

### Installation

1. **Build the Installer:**
   From the root of the project, run the `jpackage` Gradle task. This will create a native installer
   in the `cli/build/installer/` directory.
    ```bash
    ./gradlew :cli:jpackage
    ```

2. **Install the Application:**
   Navigate to `cli/build/installer/` and run the generated installer (e.g.,
   `Geministrator-1.0.0.msi` on Windows or the equivalent `.deb`/`.rpm`/`.pkg` on other systems).

3. **Run from Anywhere:**
   After installation, the `geministrator` command will be available on your system's PATH. You can
   run it from any terminal.

---

## ‚öôÔ∏è Configuration

The first time you run the application, it will create a configuration directory at
`~/.gemini-orchestrator/`. You can manage settings via the `config` command.

### Authentication: ADC vs. API Key

Geministrator supports two authentication methods. By default, it will try to use **Application
Default Credentials (ADC)** by shelling out to `gcloud`. If this fails, it will fall back to using a
standard **API Key**.

* **To set your preferred method:**
  ```bash
  # Prioritize gcloud authentication (default)
  geministrator config --auth-method adc

  # Use a manually provided API key
  geministrator config --auth-method apikey
  ```

### Completely Free Tier Mode

You can enforce the use of free-tier models and ADC authentication to prevent accidental charges. If
ADC is not configured, Geministrator will refuse to run in this mode.

* **To enable or disable free tier mode:**
  ```bash
  geministrator config --free-tier true
  geministrator config --free-tier false
  ```

### Other Settings

You can configure other operational parameters:

```bash
# Toggle the final user review before committing merged code
geministrator config -r

# Set the number of sub-tasks to run in parallel
geministrator config -c 4

# Set a custom token limit for the AI conversation history
geministrator config -t 700000

# Configure web search credentials (for the Researcher agent)
geministrator config --search-api-key "YOUR_Google Search_API_KEY"
geministrator config --search-engine-id "YOUR_PROGRAMMABLE_SEARCH_ENGINE_ID"
```

---

## üíª Usage

### Running a Workflow

The primary command is `run`. It takes a high-level prompt describing your development task.

```bash
# Run a simple task
geministrator run "Refactor the UserService class to use the new DatabaseWrapper."

# Run a more complex task with a formal specification file
geministrator run "Implement the user profile page" --spec-file "docs/specs/profile_page.md"
```

### Writing a Project Specification

For complex tasks, providing a spec file (inspired
by [Tmux-Orchestrator](https://github.com/a-s-w/tmux-orchestrator)) helps the AI generate a more
accurate master plan.

**Example `profile_page.md`:**
`markdown
PROJECT: My Web App
GOAL: Create a new user profile page.

CONSTRAINTS:

- Use the existing React component library.
- Follow current code patterns for state management.
- The page must be responsive.

DELIVERABLES:

1. A new route at `/profile`.
2. A component to display user information (name, email).
3. A form to update the user's password.
4. All new code must have corresponding unit tests.
   `

### Resuming a Session

If a workflow is paused (e.g., the AI needs clarification) or fails, the session state is saved to
`.orchestrator/session.json`. Simply re-running the original `geministrator run` command in the same
directory will prompt you to resume the workflow from where it left off.

---

## üîß Customizing Agent Behavior

The core instructions and "personality" of each AI agent are not hardcoded. They are stored in a
plain text JSON file located at `~/.gemini-orchestrator/prompts.json`. You can edit this file to
change how the agents behave.

For example, you could make the `Antagonist` more critical or instruct the `Architect` to prefer a
different coding style.

* **To reset all prompts to their original defaults:**
  ```bash
  geministrator config --reset-prompts true
  ```
  This will delete your custom `prompts.json`, and the application will use the default prompts from
  its internal resources on the next run.

---

## üìú License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.


====================================================================
FILE: .\build.gradle.kts
====================================================================
plugins {
    kotlin("jvm") version "1.9.23" apply false
    id("org.jetbrains.kotlin.plugin.serialization") version "1.9.23" apply false
    application
    id("org.panteleyev.jpackageplugin") version "1.7.3" apply false
}



====================================================================
FILE: .\settings.gradle.kts
====================================================================
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
        mavenLocal()
        maven("https://jitpack.io")
    }
    plugins {
        id("org.jetbrains.kotlin.jvm") version "1.9.23"
        id("org.jetbrains.kotlin.android") version "1.9.23" apply false
        id("org.jetbrains.kotlin.plugin.serialization") version "1.9.23"
        id("application")
        id("org.panteleyev.jpackageplugin") version "1.7.3"
        id("com.android.application") version "8.4.1" apply false
        id("org.jetbrains.intellij") version "1.17.3" apply false
    }
}

dependencyResolutionManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
        mavenLocal()
        maven("https://jitpack.io")
    }
}


rootProject.name = "geministrator"

include(":cli")
include(":app_android")
include(":plugin-android-studio")
include(":plugin-vscode")


====================================================================
FILE: .\gradle.properties
====================================================================
org.gradle.java.home=C:/Program Files/Java/jdk-21


====================================================================
FILE: .\LICENSE
====================================================================
Copyright (c) 2025 HereLiesAz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


====================================================================
FILE: .\gradle\wrapper\gradle-wrapper.properties
====================================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-9.0-milestone-1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



====================================================================
FILE: .\cli\build.gradle.kts
====================================================================
import org.panteleyev.jpackage.ImageType
import org.panteleyev.jpackage.JPackageTask
// Module-level build file for the 'app' module.
plugins {
    kotlin("jvm")
    application
    id("org.jetbrains.kotlin.plugin.serialization")
    id("org.panteleyev.jpackageplugin")
}

group = "com.hereliesaz.geministrator"
version = "1.0.0"

// Add sourceSets block to include resources
sourceSets {
    main {
        resources {
            srcDirs("src/main/resources")
        }
    }
}

repositories {
    mavenCentral()
    google()
    gradlePluginPortal()
    mavenLocal()
    maven("https://jitpack.io")
}

application {
    mainClass.set("com.hereliesaz.geministrator.MainKt")
    applicationName = "geministrator"
}

dependencies {
    // All project dependencies are now here
    implementation("org.jetbrains.kotlinx:kotlinx-cli:0.3.6")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions.jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
}

// This task gathers all dependency JARs into one place for the installer.
val copyDependencies by tasks.registering(Copy::class) {
    from(configurations.runtimeClasspath)
    into(layout.buildDirectory.dir("jpackage-input/libs"))
}

// This task copies your application's own JAR into the installer's input directory.
val copyJar by tasks.registering(Copy::class) {
    from(tasks.jar)
    into(layout.buildDirectory.dir("jpackage-input"))
}

// This configures the jpackage task, which creates the native installer.
tasks.named<JPackageTask>("jpackage") {
    dependsOn(copyDependencies, copyJar)
    appName.set("Geministrator")
    appVersion.set(project.version.toString())
    vendor.set("HereLiesAz")
    copyright.set("Copyright (c) 2025 HereLiesAz")
    mainJar.set(tasks.jar.get().archiveFileName.get())
    // Correctly specify the main class for the launcher
    mainClass.set(application.mainClass.get())

    // Uses the 'type' property with the correct 'ImageType' enum.
    type.set(ImageType.APP_IMAGE)
    // The input directory must contain your app's JAR and a 'libs' folder with all dependencies.
    input.set(layout.buildDirectory.dir("jpackage-input"))
    destination.set(layout.buildDirectory.dir("installer"))
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\Main.kt
====================================================================
package com.hereliesaz.geministrator

import com.hereliesaz.geministrator.adapter.CliAdapter
import com.hereliesaz.geministrator.adapter.CliConfigStorage
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.MultiStreamLogger
import com.hereliesaz.geministrator.common.PromptManager
import com.hereliesaz.geministrator.core.Orchestrator
import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.ExperimentalCli
import kotlinx.cli.Subcommand
import kotlinx.coroutines.runBlocking
import java.io.File

@OptIn(ExperimentalCli::class)
fun main(args: Array<String>) {
    val parser = ArgParser("geministrator")
    val configStorage = CliConfigStorage()
    val logger = MultiStreamLogger(configStorage.getConfigDirectory())
    val promptManager = PromptManager(configStorage.getConfigDirectory())
    val adapter = CliAdapter(configStorage, logger)

    class RunCommand : Subcommand("run", "Run a new workflow") {
        val prompt by argument(ArgType.String, description = "The high-level task for the AI to perform")
        val specFile by option(
            ArgType.String,
            fullName = "spec-file",
            description = "Path to a project specification markdown file."
        )

        override fun execute() {
            runBlocking {
                val geminiService = createGeminiService(configStorage, logger, adapter)
                if (geminiService == null) {
                    logger.error("Could not configure a valid authentication method. Exiting.")
                    return@runBlocking
                }

                val specFileContent = specFile?.let {
                    try {
                        File(it).readText()
                    } catch (e: Exception) {
                        logger.error("Could not read spec file at '$it'.", e)
                        null
                    }
                }

                val projectType = determineProjectType(logger)
                val orchestrator =
                    Orchestrator(adapter, logger, configStorage, promptManager, geminiService)
                orchestrator.run(
                    prompt,
                    System.getProperty("user.dir"),
                    projectType,
                    specFileContent
                )
            }
        }
    }

    class ConfigureCommand : Subcommand("config", "Configure settings") {
        val toggleReview by option(ArgType.Boolean, shortName = "r", description = "Toggle pre-commit review")
        val setConcurrency by option(ArgType.Int, shortName = "c", description = "Set concurrency limit")
        val setTokenLimit by option(ArgType.Int, shortName = "t", description = "Set token limit")
        val setSearchApiKey by option(
            ArgType.String,
            fullName = "search-api-key",
            description = "Set Google Custom Search API Key"
        )
        val setSearchEngineId by option(
            ArgType.String,
            fullName = "search-engine-id",
            description = "Set Google Programmable Search Engine ID"
        )
        val resetPrompts by option(
            ArgType.Boolean,
            fullName = "reset-prompts",
            description = "Reset all agent prompts to their default values"
        )
        val setAuthMethod by option(
            ArgType.String,
            fullName = "auth-method",
            description = "Set the preferred authentication method ('adc' or 'apikey')"
        )
        val setFreeTierOnly by option(
            ArgType.Boolean,
            fullName = "free-tier",
            description = "Toggle free tier only mode (enforces ADC auth and free models)"
        )


        override fun execute() {
            toggleReview?.let {
                val current = configStorage.loadPreCommitReview()
                configStorage.savePreCommitReview(!current)
                logger.interactive("SUCCESS: Pre-commit review set to: ${!current}")
            }
            setConcurrency?.let {
                configStorage.saveConcurrencyLimit(it)
                logger.interactive("SUCCESS: Concurrency limit set to: $it")
            }
            setTokenLimit?.let {
                configStorage.saveTokenLimit(it)
                logger.interactive("SUCCESS: Token limit set to: $it")
            }
            setSearchApiKey?.let {
                configStorage.saveSearchApiKey(it)
                logger.interactive("SUCCESS: Search API Key has been saved.")
            }
            setSearchEngineId?.let {
                configStorage.saveSearchEngineId(it)
                logger.interactive("SUCCESS: Search Engine ID has been saved.")
            }
            resetPrompts?.let {
                if (it) {
                    if (promptManager.resetToDefaults()) {
                        logger.interactive("SUCCESS: Custom prompts file deleted. System will use default prompts on next run.")
                    } else {
                        logger.error("Failed to delete custom prompts file.")
                    }
                }
            }
            setAuthMethod?.let {
                val method = it.lowercase()
                if (method == "adc" || method == "apikey") {
                    configStorage.saveAuthMethod(method)
                    logger.interactive("SUCCESS: Default authentication method set to '$method'.")
                } else {
                    logger.error("Invalid authentication method. Please choose 'adc' or 'apikey'.")
                }
            }
            setFreeTierOnly?.let {
                configStorage.saveFreeTierOnly(it)
                logger.interactive("SUCCESS: Free tier only mode set to '$it'.")
            }
        }
    }

    parser.subcommands(RunCommand(), ConfigureCommand())
    parser.parse(args)
}

private suspend fun createGeminiService(
    configStorage: CliConfigStorage,
    logger: ILogger,
    adapter: CliAdapter,
): GeminiService? {
    val freeTierOnly = configStorage.loadFreeTierOnly()
    val authMethod = if (freeTierOnly) "adc" else configStorage.loadAuthMethod()

    val strategicModel: String
    val flashModel: String

    if (freeTierOnly) {
        logger.info("Free Tier Only mode is enabled. Using free models and ADC authentication.")
        strategicModel = "gemini-1.5-pro-latest"
        flashModel = "gemini-1.5-flash-latest"
    } else {
        strategicModel = configStorage.loadModelName("strategic", "gemini-pro")
        flashModel = configStorage.loadModelName("flash", "gemini-1.5-flash-latest")
    }

    val promptManager = PromptManager(configStorage.getConfigDirectory())

    if (authMethod == "adc") {
        val service = GeminiService(
            authMethod = "adc",
            apiKey = "", // Not needed for ADC
            logger = logger,
            config = configStorage,
            strategicModelName = strategicModel,
            flashModelName = flashModel,
            promptManager = promptManager,
            adapter = adapter
        )
        if (service.isAdcAuthReady()) {
            return service
        }
        if (freeTierOnly) {
            logger.error("Free Tier Only mode requires ADC authentication, which failed. Please configure gcloud or disable free tier mode.")
            return null
        }
        logger.info("ADC authentication failed. Checking for API key as fallback...")
    }

    // Fallback to API key or if 'apikey' is the chosen method
    var apiKey = configStorage.loadApiKey()
    while (true) {
        if (!apiKey.isNullOrBlank()) {
            val serviceForValidation =
                GeminiService("apikey", apiKey, logger, configStorage, "", "", null, null)
            if (serviceForValidation.validateApiKey(apiKey)) {
                logger.info("API Key authentication successful.")
                return GeminiService(
                    "apikey",
                    apiKey,
                    logger,
                    configStorage,
                    strategicModel,
                    flashModel,
                    promptManager,
                    adapter
                )
            }
            logger.error("Your saved API key is no longer valid.")
        }
        apiKey = logger.prompt("Please enter your Gemini API Key: ")
        if (apiKey.isNullOrBlank()) return null
        configStorage.saveApiKey(apiKey)
    }
}


private fun determineProjectType(logger: ILogger): String {
    logger.interactive("\nWhat type of project are you working on?")
    val options = listOf(
        "Application",
        "Web Service/API",
        "Library/SDK",
        "Automation Script",
        "Website",
        "Other"
    )
    options.forEachIndexed { index, option -> logger.interactive("  ${index + 1}. $option") }
    while (true) {
        val choiceStr = logger.prompt("Enter your choice (number): ")
        val choice = choiceStr?.toIntOrNull()
        if (choice != null && choice in 1..options.size) {
            return options[choice - 1]
        }
        logger.error("Invalid selection. Please enter a number from the list.")
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\Manager.kt
====================================================================
package com.hereliesaz.geministrator.core

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ILogger

sealed class WorkflowStatus {
    data class Success(val commitMessage: String, val successfulSteps: List<String>) : WorkflowStatus()
    data class Failure(val reason: String) : WorkflowStatus()
    data class TestsFailed(val testOutput: String, val successfulSteps: List<String>) : WorkflowStatus()
}

class Manager(private val adapter: ExecutionAdapter, private val logger: ILogger) {
    fun executeWorkflow(workflow: List<AbstractCommand>, prompt: String): WorkflowStatus {
        logger.info("Manager starting workflow with ${workflow.size} steps.")
        if (workflow.isEmpty()) {
            logger.info("WARNING: Manager received an empty workflow. Nothing to do.")
            return WorkflowStatus.Success("No changes made.", emptyList())
        }

        val successfulSteps = mutableListOf<String>()
        for (command in workflow) {
            val commandName = command::class.simpleName ?: "UnknownCommand"
            logger.info("---")
            logger.info("  [Manager] -> Delegating command: $commandName")
            val result = adapter.execute(command)

            if (!result.isSuccess) {
                val reason = "Execution of $commandName failed: ${result.output}"
                logger.error("  ERROR: $reason")

                // If tests failed, we return a specific status for self-correction.
                if (command is AbstractCommand.RunTests) {
                    logger.error("  TESTS FAILED!")
                    return WorkflowStatus.TestsFailed(result.output, successfulSteps)
                }

                return WorkflowStatus.Failure(reason)
            }
            logger.info("  SUCCESS: ${result.output}")
            successfulSteps.add(commandName)
        }

        logger.info("---")
        logger.info("Manager completed workflow successfully.")
        return WorkflowStatus.Success(prompt, successfulSteps)
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\Orchestrator.kt
====================================================================
package com.hereliesaz.geministrator.core

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ExecutionResult
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager
import com.hereliesaz.geministrator.core.config.ConfigStorage
import com.hereliesaz.geministrator.core.council.Antagonist
import com.hereliesaz.geministrator.core.council.Architect
import com.hereliesaz.geministrator.core.council.Designer
import com.hereliesaz.geministrator.core.council.Researcher
import com.hereliesaz.geministrator.core.council.TechSupport
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonPrimitive
import kotlin.system.exitProcess

@Serializable
data class SessionState(
    val masterPlan: MasterPlan,
    val completedBranches: List<String>,
    val completedTaskIndices: Set<Int>, // Explicitly track completed task indices
    val mainBranch: String,
)

@Serializable
data class MasterPlan(val sub_tasks: List<SubTask>)

@Serializable
data class SubTask(
    val description: String,
    val responsible_component: String,
    val depends_on: List<Int> = emptyList(),
)

@Serializable
data class WorkflowPlan(val reasoning: String, val steps: List<WorkflowStep>)

@Serializable
data class WorkflowStep(val command_type: String, val parameters: JsonObject)

@Serializable
private data class TriageResult(
    val needs_web_research: Boolean = false,
    val needs_project_context: Boolean = false,
)


class Orchestrator(
    private val adapter: ExecutionAdapter,
    private val logger: ILogger,
    private val config: ConfigStorage,
    private val promptManager: PromptManager,
    private val ai: GeminiService,
) {
    private val architect: Architect
    private val researcher: Researcher
    private val designer: Designer
    private val antagonist: Antagonist
    private val techSupport: TechSupport
    private val jsonParser = Json { isLenient = true; ignoreUnknownKeys = true }
    private val MAX_RETRY_ATTEMPTS = 2
    private val JOURNAL_FILE = ".orchestrator/journal.log"
    private val SESSION_FILE = ".orchestrator/session.json"

    init {
        architect = Architect(logger, ai, adapter, promptManager)
        researcher = Researcher(logger, ai, adapter, promptManager)
        designer = Designer(logger, adapter)
        antagonist = Antagonist(logger, ai, promptManager)
        techSupport = TechSupport(logger, ai, promptManager)
    }

    fun run(prompt: String, projectRoot: String, projectType: String, specFileContent: String?) =
        runBlocking(Dispatchers.Default) {
        val sessionState = loadSessionState()
        if (sessionState != null) {
            val decision = adapter.execute(
                AbstractCommand.RequestUserDecision(
                    "An incomplete workflow was found. Do you want to resume it?",
                    listOf("Resume", "Start New")
                )
            )
            if (decision.data == "Resume") {
                logger.info("Resuming previous workflow...")
                executeMasterPlan(
                    sessionState.masterPlan,
                    projectRoot,
                    sessionState.mainBranch,
                    sessionState.completedBranches.toMutableList(),
                    sessionState.completedTaskIndices.toMutableSet()
                )
                return@runBlocking
            }
        }

        ai.clearSession()
            logger.info("Orchestrator received complex prompt: '$prompt'")
        val mainBranch = adapter.execute(AbstractCommand.GetCurrentBranch).output.trim()
            val masterPlanJson = deconstructPromptIntoSubTasks(prompt, projectType, specFileContent)
        if (masterPlanJson.startsWith("Error:")) {
            logger.error("CRITICAL: Could not deconstruct prompt into sub-tasks. AI Failure: $masterPlanJson")
            return@runBlocking
        }
        val masterPlan = jsonParser.decodeFromString<MasterPlan>(masterPlanJson)
            saveSessionState(SessionState(masterPlan, emptyList(), emptySet(), mainBranch))
            executeMasterPlan(masterPlan, projectRoot, mainBranch, mutableListOf(), mutableSetOf())
    }

    private suspend fun executeMasterPlan(
        masterPlan: MasterPlan,
        projectRoot: String,
        mainBranch: String,
        completedBranches: MutableList<String>,
        completedIndices: MutableSet<Int>,
    ) = coroutineScope {
        val integrationBranch = "integration/orchestrator-${System.currentTimeMillis()}"
        val concurrencyLimit = config.loadConcurrencyLimit()
        val semaphore = Semaphore(concurrencyLimit)
        logger.info("Orchestrator has deconstructed the prompt into ${masterPlan.sub_tasks.size} sub-tasks.")
        logger.info("Concurrency limit set to $concurrencyLimit simultaneous tasks.")

        val tasks = masterPlan.sub_tasks.withIndex().toList()
        val runningTasks = mutableSetOf<Int>()

        while (completedIndices.size < tasks.size) {
            val tasksReadyToRun = tasks.filter { (index, subTask) ->
                index !in completedIndices &&
                        index !in runningTasks &&
                        subTask.depends_on.all { it in completedIndices }
            }

            if (tasksReadyToRun.isEmpty() && runningTasks.isEmpty() && completedIndices.size < tasks.size) {
                logger.error("EXECUTION HALTED: Circular dependency or failed tasks detected. Cannot proceed.")
                saveSessionState(
                    SessionState(
                        masterPlan,
                        completedBranches,
                        completedIndices,
                        mainBranch
                    )
                )
                return@coroutineScope
            }

            val jobs = tasksReadyToRun.map { (index, subTask) ->
                runningTasks.add(index)
                async {
                    val taskResult = semaphore.withPermit {
                        val taskBranch = "feature/orchestrator-task-$index"
                        logger.info("---")
                        logger.info("[STARTING] Manager for '${subTask.description}' on branch '$taskBranch'")
                        handleTask(subTask.description, projectRoot, mutableListOf(), 0, taskBranch)
                    }
                    if (taskResult != null) {
                        completedBranches.add(taskResult)
                        completedIndices.add(index)
                        saveSessionState(
                            SessionState(
                                masterPlan,
                                completedBranches,
                                completedIndices,
                                mainBranch
                            )
                        )
                    }
                    runningTasks.remove(index)
                    taskResult != null
                }
            }

            val results = jobs.awaitAll()
            if (results.any { !it }) {
                logger.error("One or more tasks failed in the current wave. Halting further execution.")
                saveSessionState(
                    SessionState(
                        masterPlan,
                        completedBranches,
                        completedIndices,
                        mainBranch
                    )
                )
                return@coroutineScope
            }
        }

        logger.info("All sub-tasks completed. Beginning final integration.")
        adapter.execute(AbstractCommand.CreateAndSwitchToBranch(integrationBranch))
        var mergeSuccess = true
        var mergeResult: ExecutionResult? = null
        for (branch in completedBranches) {
            mergeResult = adapter.execute(AbstractCommand.MergeBranch(branch))
            if (!mergeResult.isSuccess) {
                logger.error("CRITICAL: Merge conflict detected when merging '$branch'. Halting integration.")
                mergeSuccess = false
                break
            }
        }

        if (mergeSuccess) {
            val commitMessage =
                "feat: ${masterPlan.sub_tasks.joinToString(", ") { it.description }}"
            if (config.loadPreCommitReview()) {
                val reviewResult =
                    adapter.execute(AbstractCommand.RequestCommitReview(commitMessage))
                if (reviewResult.data != "APPROVE") {
                    logger.info("User rejected the final commit. Rolling back.")
                    cleanup(integrationBranch, completedBranches, mainBranch)
                    return@coroutineScope
                }
            }
            adapter.execute(AbstractCommand.SwitchToBranch(mainBranch))
            adapter.execute(AbstractCommand.MergeBranch(integrationBranch))
            designer.updateChangelog(commitMessage)
            cleanup(integrationBranch, completedBranches, mainBranch)
        } else {
            val analysis = techSupport.analyzeMergeConflict(mergeResult?.output ?: "Unknown error")
            logger.info("--- TECH SUPPORT ANALYSIS ---\n$analysis")
            val userDecision = adapter.execute(
                AbstractCommand.RequestUserDecision(
                    "A merge conflict occurred. What should we do?",
                    listOf("Abandon", "Attempt AI Fix")
                )
            )
            if (userDecision.data == "Attempt AI Fix") {
                handleTask(
                    "Resolve merge conflict based on Tech Support analysis",
                    projectRoot,
                    mutableListOf(analysis),
                    0,
                    integrationBranch,
                    createBranch = false
                )
            } else {
                cleanup(integrationBranch, completedBranches, mainBranch)
            }
        }
    }

    private fun handleTask(prompt: String, projectRoot: String, context: MutableList<String>, attempt: Int, branch: String, createBranch: Boolean = true): String? {
        logJournal("START_TASK", mapOf("prompt" to prompt, "branch" to branch, "attempt" to attempt))

        if (createBranch) {
            adapter.execute(AbstractCommand.CreateAndSwitchToBranch(branch))
        }

        if (attempt > MAX_RETRY_ATTEMPTS) {
            logger.error("Maximum retry attempts reached for task '$prompt'. Halting this sub-task.")
            designer.recordHistoricalLesson("Sub-task '$prompt' failed after $MAX_RETRY_ATTEMPTS self-correction attempts.")
            return null
        }

        if (attempt == 0 && createBranch) {
            val specWorkflow = designer.createSpecification(prompt)
            Manager(adapter, logger).executeWorkflow(specWorkflow, prompt)
        }

        logger.info("Triaging task to determine necessary agents...")
        val triagePrompt =
            promptManager.getPrompt("orchestrator.triageTask", mapOf("task" to prompt))
        val triageJson = ai.executeFlashPrompt(triagePrompt)
        val triageResult = try {
            jsonParser.decodeFromString<TriageResult>(triageJson)
        } catch (e: Exception) {
            logger.error("Could not parse triage result, defaulting to full context.", e)
            TriageResult(needs_web_research = true, needs_project_context = true)
        }
        logger.info("  -> Triage result: Web research needed: ${triageResult.needs_web_research}, Project context needed: ${triageResult.needs_project_context}")


        val bestPractices = if (triageResult.needs_web_research) {
            researcher.findBestPracticesFor(prompt)
        } else {
            ""
        }

        val projectContext = if (triageResult.needs_project_context) {
            architect.getProjectContextFor(prompt, projectRoot)
        } else {
            ""
        }

        val allContext = context + listOf(bestPractices, projectContext).filter { it.isNotBlank() }
        val planJson = generatePlanWithAI(prompt, *allContext.toTypedArray())

        if (planJson.startsWith("Error:")) {
            logger.error("Failed to generate a plan for '$prompt'. AI Failure: $planJson. Halting task.")
            return null
        }

        val workflowPlan = jsonParser.decodeFromString<WorkflowPlan>(planJson)
        logger.info("AI Reasoning: ${workflowPlan.reasoning}")

        val workflow = convertPlanToWorkflow(workflowPlan)
        if (workflow.isEmpty() && !workflowPlan.reasoning.contains("No changes needed")) {
            logger.error("Generated an empty or invalid workflow. Halting task.")
            return null
        }

        val pauseCommand = workflow.filterIsInstance<AbstractCommand.PauseAndExit>().firstOrNull()
        if (pauseCommand != null) {
            logger.interactive("\n--- EXECUTION PAUSED BY AI ---")
            logger.interactive(pauseCommand.checkInMessage)
            logger.interactive("To resume, run Geministrator again. State has been saved.")
            exitProcess(0)
        }


        if (workflow.size == 1 && workflow.first() is AbstractCommand.RequestClarification) {
            val clarificationCommand = workflow.first() as AbstractCommand.RequestClarification
            val result = adapter.execute(clarificationCommand)
            val userAnswer = result.data as? String ?: "No response."
            context.add("User Clarification: $userAnswer")
            return handleTask(prompt, projectRoot, context, attempt, branch, createBranch)
        }

        val objection = antagonist.reviewPlan(planJson)
        if (objection != null) {
            logger.info("--- INITIATING SELF-CORRECTION (Attempt ${attempt + 1}) ---")
            context.add("The previous plan was rejected by the Antagonist. Reason: $objection")
            context.add("Please generate a new, valid plan that addresses this specific objection.")
            return handleTask(prompt, projectRoot, context, attempt + 1, branch, createBranch)
        }

        val manager = Manager(adapter, logger)
        val status = manager.executeWorkflow(workflow, prompt)

        return when (status) {
            is WorkflowStatus.Success -> {
                adapter.execute(AbstractCommand.Commit("WIP: ${status.commitMessage}"))
                logJournal("TASK_SUCCESS", mapOf("branch" to branch))
                branch
            }
            is WorkflowStatus.TestsFailed -> {
                logger.info("--- INITIATING SELF-CORRECTION (Attempt ${attempt + 1}) ---")
                context.add("The previous attempt failed with this test error:\n${status.testOutput}")
                context.add("These steps were successful before the failure:\n${status.successfulSteps.joinToString("\n")}")
                handleTask(prompt, projectRoot, context, attempt + 1, branch, createBranch)
            }
            is WorkflowStatus.Failure -> {
                logJournal("TASK_FAILURE", mapOf("branch" to branch, "reason" to status.reason))
                null
            }
        }
    }

    private fun deconstructPromptIntoSubTasks(
        userPrompt: String,
        projectType: String,
        specFileContent: String?,
    ): String {
        val specContent = if (specFileContent != null) {
            "PROJECT SPECIFICATION:\n$specFileContent"
        } else {
            ""
        }
        val prompt = promptManager.getPrompt(
            "orchestrator.deconstructPrompt", mapOf(
                "userPrompt" to userPrompt,
                "projectType" to projectType,
                "specFileContent" to specContent
            )
        )
        return ai.executeStrategicPrompt(prompt)
    }

    private fun cleanup(integrationBranch: String?, featureBranches: List<String>, mainBranch: String) {
        logger.info("Cleaning up temporary branches...")
        adapter.execute(AbstractCommand.SwitchToBranch(mainBranch))
        featureBranches.forEach { adapter.execute(AbstractCommand.DeleteBranch(it)) }
        integrationBranch?.let { adapter.execute(AbstractCommand.DeleteBranch(it)) }
        adapter.execute(AbstractCommand.DeleteFile(SESSION_FILE))
        adapter.execute(AbstractCommand.DeleteFile(JOURNAL_FILE))
        logger.info("Cleanup complete.")
    }

    private fun logJournal(action: String, data: Map<String, Any>) {
        val dataJsonObject = JsonObject(data.mapValues { (_, value) ->
            when (value) {
                is String -> JsonPrimitive(value)
                is Number -> JsonPrimitive(value)
                is Boolean -> JsonPrimitive(value)
                else -> JsonPrimitive(value.toString()) // Fallback for other types
            }
        })
        val entry =
            "{\"timestamp\": ${java.lang.System.currentTimeMillis()}, \"action\": \"$action\", \"data\": ${
                jsonParser.encodeToString(
                    JsonObject.serializer(),
                    dataJsonObject
                )
            }}\n"
        adapter.execute(AbstractCommand.LogJournalEntry(entry))
    }

    private fun saveSessionState(state: SessionState) {
        val json = jsonParser.encodeToString(SessionState.serializer(), state)
        adapter.execute(AbstractCommand.WriteFile(SESSION_FILE, json))
    }

    private fun loadSessionState(): SessionState? {
        val result = adapter.execute(AbstractCommand.ReadFile(SESSION_FILE))
        return if (result.isSuccess && result.data is String && (result.data.isNotBlank())) {
            try {
                jsonParser.decodeFromString(SessionState.serializer(), result.data)
            } catch (e: Exception) {
                logger.error("Could not parse session file, starting new session.", e)
                null
            }
        } else null
    }

    private fun generatePlanWithAI(userPrompt: String, vararg context: String): String {
        logger.info("Orchestrator: Generating workflow plan with AI...")
        val systemPrompt = promptManager.getPrompt(
            "orchestrator.generatePlan",
            mapOf("context" to context.joinToString("\n---\n"), "userPrompt" to userPrompt)
        )
        return ai.executeStrategicPrompt(systemPrompt)
    }

    private fun convertPlanToWorkflow(plan: WorkflowPlan): List<AbstractCommand> {
        return plan.steps.mapNotNull { step ->
            when (step.command_type) {
                "WRITE_FILE" -> {
                    val path =
                        step.parameters["path"]?.jsonPrimitive?.content ?: return@mapNotNull null
                    val content =
                        step.parameters["content"]?.jsonPrimitive?.content ?: return@mapNotNull null
                    AbstractCommand.WriteFile(path, content)
                }

                "RUN_SHELL" -> {
                    val command =
                        step.parameters["command"]?.jsonArray?.mapNotNull { it.jsonPrimitive.content }
                            ?: return@mapNotNull null
                    val workDir = step.parameters["workingDir"]?.jsonPrimitive?.content ?: "."
                    AbstractCommand.RunShellCommand(command, workDir)
                }

                "RUN_TESTS" -> {
                    val module = step.parameters["module"]?.jsonPrimitive?.content
                    val testName = step.parameters["testName"]?.jsonPrimitive?.content
                    AbstractCommand.RunTests(module, testName)
                }

                "DISPLAY_MESSAGE" -> {
                    val message =
                        step.parameters["message"]?.jsonPrimitive?.content ?: return@mapNotNull null
                    AbstractCommand.DisplayMessage(message)
                }

                "STAGE_FILES" -> {
                    val paths =
                        step.parameters["paths"]?.jsonArray?.mapNotNull { it.jsonPrimitive.content }
                            ?: return@mapNotNull null
                    AbstractCommand.StageFiles(paths)
                }

                "REQUEST_CLARIFICATION" -> {
                    val question = step.parameters["question"]?.jsonPrimitive?.content
                        ?: return@mapNotNull null
                    AbstractCommand.RequestClarification(question)
                }
                "PAUSE_AND_EXIT" -> {
                    val message = step.parameters["checkInMessage"]?.jsonPrimitive?.content
                        ?: "Execution paused."
                    AbstractCommand.PauseAndExit(message)
                }
                else -> null
            }
        }
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\config\ConfigStorage.kt
====================================================================
package com.hereliesaz.geministrator.core.config

interface ConfigStorage {
    fun saveApiKey(apiKey: String)
    fun loadApiKey(): String?
    fun savePreCommitReview(enabled: Boolean)
    fun loadPreCommitReview(): Boolean
    fun saveModelName(type: String, name: String)
    fun loadModelName(type: String, default: String): String
    fun saveConcurrencyLimit(limit: Int)
    fun loadConcurrencyLimit(): Int
    fun saveTokenLimit(limit: Int)
    fun loadTokenLimit(): Int

    // New methods for search configuration
    fun saveSearchApiKey(apiKey: String)
    fun loadSearchApiKey(): String?
    fun saveSearchEngineId(id: String)
    fun loadSearchEngineId(): String?

    // New methods for auth
    fun saveAuthMethod(method: String)
    fun loadAuthMethod(): String
    fun saveFreeTierOnly(enabled: Boolean)
    fun loadFreeTierOnly(): Boolean
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\Antagonist.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager

class Antagonist(
    private val logger: ILogger,
    private val ai: GeminiService,
    private val promptManager: PromptManager,
) {
    fun reviewPlan(planJson: String): String? {
        logger.info("Antagonist: Reviewing the proposed workflow...")
        val prompt = promptManager.getPrompt("antagonist.reviewPlan", mapOf("planJson" to planJson))
        val review = ai.executeStrategicPrompt(prompt)
        if (review.startsWith("OBJECTION:")) {
            logger.info("Antagonist: $review")
            return review
        }
        logger.info("Antagonist: The plan seems reasonable. No objections.")
        return null
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\Architect.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager
import java.io.File

class Architect(
    private val logger: ILogger,
    private val ai: GeminiService,
    private val adapter: ExecutionAdapter,
    private val promptManager: PromptManager,
) {
    fun getProjectContextFor(task: String, projectRoot: String): String {
        logger.info("Architect: Performing deep context analysis for '$task'.")
        val fileTree = File(projectRoot).walk().maxDepth(5)
            .filter { it.isFile && !it.path.contains(".git") && !it.path.contains(".idea") }
            .joinToString("\n") { it.relativeTo(File(projectRoot)).path }
        val triagePrompt = promptManager.getPrompt(
            "architect.getProjectContext",
            mapOf("fileTree" to fileTree, "task" to task)
        )
        val relevantFilePaths = ai.executeFlashPrompt(triagePrompt).split(",").map { it.trim() }
        logger.info("  -> Architect identified relevant files: $relevantFilePaths")
        val contextBuilder = StringBuilder("RELEVANT FILE CONTEXT:\n")
        relevantFilePaths.forEach { path ->
            if (path.isNotBlank()) {
                val result = adapter.execute(AbstractCommand.ReadFile(path))
                if (result.isSuccess) {
                    contextBuilder.append("--- FILE: $path ---\n")
                    contextBuilder.append((result.data as? String) ?: "Could not read file.")
                    contextBuilder.append("\n\n")
                }
            }
        }
        return contextBuilder.toString()
    }

    fun reviewStagedChanges(changes: Map<String, String>): Boolean {
        logger.info("Architect: Reviewing ${changes.size} staged files for architectural compliance.")
        val prompt = promptManager.getPrompt(
            "architect.reviewStagedChanges",
            mapOf("changes" to changes.toString())
        )
        val decision = ai.executeStrategicPrompt(prompt)
        logger.info("Architect's Decision: $decision")
        return decision.startsWith("APPROVE")
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\Designer.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ILogger

class Designer(private val logger: ILogger, private val adapter: ExecutionAdapter) {
    fun createSpecification(feature: String): List<AbstractCommand> {
        logger.info("Designer: Creating feature specification for '$feature'.")
        val sanitizedFeature = feature.replace(" ", "_").replace(Regex("[^A-Za-z0-9_]"), "")
        return listOf(AbstractCommand.WriteFile(
            path = "docs/specs/$sanitizedFeature.md",
            content = "# Feature: $feature\n\nThis feature should allow users to..."
        ))
    }
    fun updateChangelog(commitMessage: String) {
        logger.info("Designer: Updating changelog.")
        adapter.execute(AbstractCommand.AppendToFile("CHANGELOG.md", "\n- $commitMessage"))
    }
    fun recordHistoricalLesson(lesson: String) {
        logger.info("Designer: Recording important lesson in project history.")
        adapter.execute(AbstractCommand.AppendToFile("docs/history.md", "\n- $lesson"))
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\Researcher.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager

class Researcher(
    private val logger: ILogger,
    private val ai: GeminiService,
    private val adapter: ExecutionAdapter,
    private val promptManager: PromptManager,
) {
    fun findBestPracticesFor(topic: String): String {
        logger.info("Researcher: Searching for best practices regarding '$topic'.")
        val searchResult = adapter.execute(AbstractCommand.PerformWebSearch(topic))
        val prompt = promptManager.getPrompt(
            "researcher.findBestPractices",
            mapOf("searchResults" to searchResult.output, "topic" to topic)
        )
        return ai.executeFlashPrompt(prompt)
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\TechSupport.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager

class TechSupport(
    private val logger: ILogger,
    private val ai: GeminiService,
    private val promptManager: PromptManager,
) {
    fun analyzeMergeConflict(conflictOutput: String): String {
        logger.info("Tech Support: Analyzing merge conflict...")
        val prompt = promptManager.getPrompt(
            "techSupport.analyzeMergeConflict",
            mapOf("conflictOutput" to conflictOutput)
        )
        return ai.executeStrategicPrompt(prompt)
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\tokenizer\Tokenizer.kt
====================================================================
package com.hereliesaz.geministrator.core.tokenizer

object Tokenizer {
    /**
     * A simple heuristic to approximate token count.
     * The official Gemini tokenizer is more complex, but a common rule of thumb
     * is that one token is approximately 4 characters for English text.
     */
    fun countTokens(text: String): Int {
        return (text.length / 4.0).toInt()
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\GeminiService.kt
====================================================================
package com.hereliesaz.geministrator.common

import com.hereliesaz.geministrator.core.config.ConfigStorage
import com.hereliesaz.geministrator.core.tokenizer.Tokenizer
import kotlinx.serialization.Serializable
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.json.Json
import java.net.HttpURLConnection
import java.net.URI

// Request/Response structures for serialization
@Serializable private data class GeminiRequest(val model: String, val contents: List<Content>)
@Serializable private data class GeminiResponse(val candidates: List<Candidate>)
@Serializable data class Candidate(val content: Content)
@Serializable data class Content(val parts: List<Part>, val role: String? = null)
@Serializable data class Part(val text: String)


class GeminiService(
    private val authMethod: String,
    private var apiKey: String,
    private val logger: ILogger,
    private val config: ConfigStorage,
    private val strategicModelName: String,
    private val flashModelName: String,
    private val promptManager: PromptManager? = null,
    private val adapter: ExecutionAdapter? = null, // Adapter for running gcloud
) {
    private val jsonParser = Json { isLenient = true; ignoreUnknownKeys = true }
    private val conversationHistory = mutableListOf<Content>()
    private var authToken: String? = null

    init {
        if (authMethod == "adc") {
            tryToGetAdcToken()
        }
    }

    private fun tryToGetAdcToken() {
        val result = adapter?.execute(
            AbstractCommand.RunShellCommand(
                listOf(
                    "gcloud",
                    "auth",
                    "application-default",
                    "print-access-token"
                )
            ), silent = true
        )
        if (result != null && result.isSuccess && result.output.isNotBlank()) {
            authToken = result.output.trim()
        }
    }

    fun isAdcAuthReady(): Boolean = authToken != null


    fun executeStrategicPrompt(prompt: String): String = executePrompt(prompt, strategicModelName)
    fun executeFlashPrompt(prompt: String): String = executePrompt(prompt, flashModelName)

    private fun executePrompt(prompt: String, model: String): String {
        if (authMethod == "apikey" && apiKey.isBlank()) {
            logger.error("Authentication failed. No API key is configured for 'apikey' method.")
            return "Error: Authentication failed."
        }
        if (authMethod == "adc" && authToken == null) {
            logger.error("Authentication failed. Could not obtain ADC token.")
            return "Error: Authentication failed."
        }

        conversationHistory.add(Content(parts = listOf(Part(prompt)), role = "user"))

        val tokenLimit = config.loadTokenLimit()
        val currentTokens = Tokenizer.countTokens(jsonParser.encodeToString(ListSerializer(Content.serializer()), conversationHistory))

        if (currentTokens > tokenLimit) {
            logger.info("WARNING: Token limit reached ($currentTokens / $tokenLimit). Performing graceful session restart.")
            val historyText = conversationHistory.joinToString("\n") { c -> "${c.role}: ${c.parts.first().text}" }
            val summaryPrompt = promptManager!!.getPrompt(
                "geminiService.summarizeSession",
                mapOf("historyText" to historyText)
            )
            val summary = internalExecute(summaryPrompt, model)
            logger.info("  -> Session summary created.")
            conversationHistory.clear()
            conversationHistory.add(Content(parts = listOf(Part("This is a new session. Here is the summary of the previous one to provide context:\n$summary")), role = "user"))
            conversationHistory.add(Content(parts = listOf(Part(prompt)), role = "user"))
        }

        val responseText = internalExecute(prompt, model, conversationHistory)
        conversationHistory.add(Content(parts = listOf(Part(responseText)), role = "model"))
        return responseText
    }

    private fun internalExecute(prompt: String, model: String, history: List<Content>? = null): String {
        logger.info("  -> Calling AI Model ($model) using auth method: $authMethod...")

        val baseUrl =
            "https://generativelanguage.googleapis.com/v1beta/models/$model:generateContent"

        val url = if (authMethod == "apikey") {
            URI("$baseUrl?key=$apiKey").toURL()
        } else {
            URI(baseUrl).toURL()
        }

        val connection = url.openConnection() as HttpURLConnection
        connection.requestMethod = "POST"
        connection.setRequestProperty("Content-Type", "application/json")
        connection.doOutput = true

        if (authMethod == "adc" && authToken != null) {
            connection.setRequestProperty("Authorization", "Bearer $authToken")
        }

        val request = GeminiRequest(model, history ?: listOf(Content(parts=listOf(Part(prompt)))))
        val requestBody = jsonParser.encodeToString(GeminiRequest.serializer(), request)

        connection.outputStream.use { it.write(requestBody.toByteArray(Charsets.UTF_8)) }

        return if (connection.responseCode == HttpURLConnection.HTTP_OK) {
            val responseText = connection.inputStream.bufferedReader().readText()
            try {
                jsonParser.decodeFromString<GeminiResponse>(responseText).candidates.first().content.parts.first().text
            } catch (e: Exception) {
                logger.error("Error parsing Gemini response: $responseText", e)
                "Error: Could not parse AI response."
            }
        } else {
            val error = connection.errorStream.bufferedReader().readText()
            logger.error("API call failed: $error")
            "Error: API call failed with status ${connection.responseCode}. Details: $error"
        }
    }

    fun clearSession() { conversationHistory.clear() }

    suspend fun validateApiKey(keyToValidate: String): Boolean {
        logger.info("  -> Validating API Key...")
        val url =
            URI("https://generativelanguage.googleapis.com/v1beta/models?key=$keyToValidate").toURL()
        return try {
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            val isValid = connection.responseCode == HttpURLConnection.HTTP_OK
            logger.info(if (isValid) "  -> API Key is valid." else "  -> API Key is invalid.")
            isValid
        } catch (e: Exception) {
            logger.error("  -> API Key validation failed with an exception", e)
            false
        }
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\PluginConfigStorage.kt
====================================================================
package com.hereliesaz.Geministrator.plugins

import com.hereliesaz.Geministrator.core.config.ConfigStorage
import com.intellij.ide.util.PropertiesComponent

class PluginConfigStorage : ConfigStorage {
    private val props = PropertiesComponent.getInstance()
    private val ID_API_KEY = "com.hereliesaz.GeminiOrchestrator.apiKey"
    private val ID_REVIEW_ENABLED = "com.hereliesaz.GeminiOrchestrator.reviewEnabled"
    private val ID_CONCURRENCY_LIMIT = "com.hereliesaz.GeminiOrchestrator.concurrencyLimit"
    private val ID_TOKEN_LIMIT = "com.hereliesaz.GeminiOrchestrator.tokenLimit"
    private val ID_MODEL_STRATEGIC = "com.hereliesaz.GeminiOrchestrator.modelStrategic"
    private val ID_MODEL_FLASH = "com.hereliesaz.GeminiOrchestrator.modelFlash"

    override fun saveApiKey(apiKey: String) = props.setValue(ID_API_KEY, apiKey)
    override fun loadApiKey(): String? = props.getValue(ID_API_KEY)
    override fun savePreCommitReview(enabled: Boolean) = props.setValue(ID_REVIEW_ENABLED, enabled, true)
    override fun loadPreCommitReview(): Boolean = props.getBoolean(ID_REVIEW_ENABLED, true)
    override fun saveConcurrencyLimit(limit: Int) = props.setValue(ID_CONCURRENCY_LIMIT, limit, 2)
    override fun loadConcurrencyLimit(): Int = props.getInt(ID_CONCURRENCY_LIMIT, 2)
    override fun saveTokenLimit(limit: Int) = props.setValue(ID_TOKEN_LIMIT, limit, 500000)
    override fun loadTokenLimit(): Int = props.getInt(ID_TOKEN_LIMIT, 500000)
    override fun saveModelName(type: String, name: String) = props.setValue(if (type == "strategic") ID_MODEL_STRATEGIC else ID_MODEL_FLASH, name)
    override fun loadModelName(type: String, default: String): String = props.getValue(if (type == "strategic") ID_MODEL_STRATEGIC else ID_MODEL_FLASH, default)
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\AbstractCommand.kt
====================================================================
package com.hereliesaz.geministrator.common

/**
 * The complete, final set of universal commands for the agent system.
 */
sealed interface AbstractCommand {
    // File System
    data class WriteFile(val path: String, val content: String) : AbstractCommand
    data class ReadFile(val path: String) : AbstractCommand
    data class AppendToFile(val path: String, val content: String) : AbstractCommand
    data class DeleteFile(val path: String) : AbstractCommand
    data class LogJournalEntry(val entry: String) : AbstractCommand

    // Execution
    data class RunShellCommand(val command: List<String>, val workingDir: String = ".") :
        AbstractCommand
    data class RunTests(val module: String?, val testName: String?) : AbstractCommand

    // Version Control
    object GetCurrentBranch : AbstractCommand
    data class CreateAndSwitchToBranch(val branchName: String) : AbstractCommand
    data class SwitchToBranch(val branchName: String) : AbstractCommand
    data class MergeBranch(val branchName: String) : AbstractCommand
    data class DeleteBranch(val branchName: String) : AbstractCommand
    data class StageFiles(val filePaths: List<String>) : AbstractCommand
    data class Commit(val message: String) : AbstractCommand
    object DiscardAllChanges : AbstractCommand

    // UI & User Interaction
    data class DisplayMessage(val message: String) : AbstractCommand
    data class RequestUserDecision(val prompt: String, val options: List<String>) : AbstractCommand
    data class RequestCommitReview(val proposedCommitMessage: String) : AbstractCommand
    data class RequestClarification(val question: String) : AbstractCommand

    // External Tools
    data class PerformWebSearch(val query: String) : AbstractCommand

    // Orchestration Control
    data class PauseAndExit(val checkInMessage: String) : AbstractCommand
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\ExecutionAdapter.kt
====================================================================
package com.hereliesaz.geministrator.common

interface ExecutionAdapter {
    fun execute(command: AbstractCommand, silent: Boolean = false): ExecutionResult
}

data class ExecutionResult(
    val isSuccess: Boolean,
    val output: String,
    val data: Any? = null
)


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\ILogger.kt
====================================================================
package com.hereliesaz.geministrator.common

interface ILogger {
    fun info(message: String)
    fun error(message: String, e: Throwable? = null)
    fun interactive(message: String)
    fun prompt(message: String): String?
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\MultiStreamLogger.kt
====================================================================
package com.hereliesaz.geministrator.common

import java.io.File
import java.io.FileWriter
import java.io.PrintWriter
import java.text.SimpleDateFormat
import java.util.Date

class MultiStreamLogger(configDir: File) : ILogger {
    private val logFile: File

    init {
        configDir.mkdirs()
        logFile = File(configDir, "geministrator.log")
    }

    private fun writeToFile(level: String, message: String, e: Throwable? = null) {
        val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(Date())
        PrintWriter(FileWriter(logFile, true)).use { writer ->
            writer.println("[$timestamp] [$level] $message")
            e?.let { ex -> ex.printStackTrace(writer) }
        }
    }

    override fun info(message: String) {
        writeToFile("INFO", message)
    }

    override fun error(message: String, e: Throwable?) {
        val fullMessage = if (e != null) "$message: ${e.message}" else message
        System.err.println("[ERROR] $fullMessage")
        writeToFile("ERROR", message, e)
    }

    override fun interactive(message: String) {
        println(message)
        writeToFile("INTERACTIVE", message)
    }

    override fun prompt(message: String): String? {
        print(message)
        writeToFile("PROMPT", message)
        val response = readlnOrNull()
        writeToFile("RESPONSE", response ?: "<empty>")
        return response
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\PromptManager.kt
====================================================================
package com.hereliesaz.geministrator.common

import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonObject
import java.io.File

class PromptManager(private val configDir: File) {

    private val prompts: Map<String, String>

    init {
        val customPromptsFile = File(configDir, "prompts.json")
        prompts = if (customPromptsFile.exists()) {
            loadPromptsFromFile(customPromptsFile)
        } else {
            loadDefaultPrompts()
        }
    }

    private fun loadPromptsFromFile(file: File): Map<String, String> {
        return try {
            val json = Json.parseToJsonElement(file.readText()).jsonObject
            json.mapValues { it.value.toString().trim('"') }
        } catch (e: Exception) {
            println("[WARNING] Could not parse custom prompts.json. Falling back to defaults. Error: ${e.message}")
            loadDefaultPrompts()
        }
    }

    private fun loadDefaultPrompts(): Map<String, String> {
        val resourceStream = this::class.java.getResourceAsStream("/prompts.json")
            ?: throw IllegalStateException("Default prompts.json not found in resources.")
        val json = Json.parseToJsonElement(resourceStream.bufferedReader().readText()).jsonObject
        return json.mapValues { it.value.toString().trim('"') }
    }

    fun getPrompt(key: String, replacements: Map<String, String> = emptyMap()): String {
        var prompt = prompts[key] ?: throw IllegalArgumentException("Prompt key '$key' not found.")
        replacements.forEach { (placeholder, value) ->
            prompt = prompt.replace("{{${placeholder}}}", value)
        }
        return prompt
    }

    fun resetToDefaults(): Boolean {
        val customPromptsFile = File(configDir, "prompts.json")
        return if (customPromptsFile.exists()) {
            customPromptsFile.delete()
        } else {
            true // Already using defaults
        }
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\adapter\CliAdapter.kt
====================================================================
package com.hereliesaz.geministrator.adapter

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ExecutionResult
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.core.config.ConfigStorage
import kotlinx.serialization.json.Json
import java.io.File
import java.io.IOException
import java.net.HttpURLConnection
import java.net.URI
import java.net.URLEncoder
import java.util.concurrent.TimeUnit

class CliAdapter(
    private val config: ConfigStorage,
    private val logger: ILogger,
) : ExecutionAdapter {
    private val jsonParser = Json { isLenient = true; ignoreUnknownKeys = true }

    override fun execute(command: AbstractCommand, silent: Boolean): ExecutionResult {
        return when (command) {
            is AbstractCommand.AppendToFile -> try {
                File(command.path).appendText(command.content); ExecutionResult(
                    true,
                    "Appended to ${command.path}"
                )
            } catch (e: IOException) {
                ExecutionResult(false, e.message ?: "Failed to append")
            }

            is AbstractCommand.CreateAndSwitchToBranch -> runCommand(
                listOf(
                    "git",
                    "checkout",
                    "-b",
                    command.branchName
                ), silent = silent
            )

            is AbstractCommand.DeleteBranch -> runCommand(
                listOf(
                    "git",
                    "branch",
                    "-D",
                    command.branchName
                ), silent = silent
            )

            is AbstractCommand.DeleteFile -> try {
                File(command.path).delete(); ExecutionResult(true, "Deleted ${command.path}")
            } catch (e: SecurityException) {
                ExecutionResult(false, "Failed to delete file: ${e.message}")
            }
            is AbstractCommand.DiscardAllChanges -> {
                val resetResult =
                    runCommand(listOf("git", "reset", "--hard", "HEAD"), silent = silent)
                if (!resetResult.isSuccess) return resetResult
                runCommand(listOf("git", "clean", "-fd"), silent = silent)
            }

            is AbstractCommand.GetCurrentBranch -> runCommand(
                listOf(
                    "git",
                    "rev-parse",
                    "--abbrev-ref",
                    "HEAD"
                ), silent = silent
            )
            is AbstractCommand.LogJournalEntry -> try {
                val file = File(".orchestrator/journal.log")
                file.parentFile.mkdirs()
                file.appendText(command.entry)
                ExecutionResult(true, "Logged journal entry")
            } catch (e: IOException) {
                ExecutionResult(false, e.message ?: "Failed to log journal entry")
            }

            is AbstractCommand.MergeBranch -> runCommand(
                listOf("git", "merge", command.branchName),
                silent = silent
            )
            is AbstractCommand.PerformWebSearch -> performWebSearch(command.query)
            is AbstractCommand.ReadFile -> try {
                ExecutionResult(true, "Read file successfully.", File(command.path).readText())
            } catch (e: IOException) {
                ExecutionResult(false, "Failed to read file: ${e.message}")
            }

            is AbstractCommand.RequestClarification -> {
                logger.interactive("\n--- CLARIFICATION REQUIRED ---\n${command.question}")
                val response = logger.prompt("Your response: ") ?: ""
                ExecutionResult(true, "User provided clarification.", response)
            }
            is AbstractCommand.RequestCommitReview -> {
                logger.interactive("\n--- PENDING COMMIT: FINAL REVIEW ---\nProposed Commit Message: \"${command.proposedCommitMessage}\"\n--- STAGED CHANGES ---")
                val diffResult = runCommand(listOf("git", "diff", "--staged"))
                logger.interactive(diffResult.output)
                val response = logger.prompt("Approve and commit these changes? (y/n): ")
                val choice = if (response?.lowercase() == "y") "APPROVE" else "REJECT"
                ExecutionResult(true, "User chose '$choice'", choice)
            }

            is AbstractCommand.RequestUserDecision -> {
                logger.interactive("\n--- USER DECISION REQUIRED ---\n${command.prompt}")
                command.options.forEachIndexed { index, option -> logger.interactive("  ${index + 1}. $option") }
                val choiceStr = logger.prompt("Enter your choice (number): ")
                val choice = choiceStr?.toIntOrNull()
                val selection = choice?.let { command.options.getOrNull(it - 1) } ?: "Cancel"
                ExecutionResult(true, "User chose '$selection'", selection)
            }

            is AbstractCommand.RunShellCommand -> runCommand(
                command.command,
                command.workingDir,
                silent
            )
            is AbstractCommand.RunTests -> {
                val cmd = mutableListOf("./gradlew")
                val task = if (command.module != null) ":${command.module}:test" else "test"
                cmd.add(task)
                command.testName?.let {
                    cmd.add("--tests")
                    cmd.add(it)
                }
                cmd.add("--info")
                runCommand(cmd, ".", silent)
            }

            is AbstractCommand.StageFiles -> runCommand(
                listOf("git", "add") + command.filePaths,
                silent = silent
            )

            is AbstractCommand.SwitchToBranch -> runCommand(
                listOf(
                    "git",
                    "checkout",
                    command.branchName
                ), silent = silent
            )

            is AbstractCommand.WriteFile -> try {
                val file =
                    File(command.path); file.parentFile.mkdirs(); file.writeText(command.content); ExecutionResult(
                    true,
                    "Wrote to ${command.path}"
                )
            } catch (e: IOException) {
                ExecutionResult(false, e.message ?: "Failed to write file")
            }

            is AbstractCommand.Commit -> runCommand(
                listOf("git", "commit", "-m", command.message),
                silent = silent
            )

            is AbstractCommand.DisplayMessage -> {
                logger.interactive("[INFO] ${command.message}"); ExecutionResult(
                    true,
                    "Message displayed"
                )
            }

            is AbstractCommand.PauseAndExit -> TODO()
        }
    }

    private fun runCommand(
        command: List<String>,
        workDir: String = ".",
        silent: Boolean = false,
    ): ExecutionResult {
        if (!silent) {
            logger.info("  [CLI Adapter] Executing: '${command.joinToString(" ")}'")
        }
        return try {
            val process =
                ProcessBuilder(command).directory(File(workDir)).redirectErrorStream(true).start()
            val output = process.inputStream.bufferedReader().readText()
            process.waitFor(120, TimeUnit.SECONDS)
            if (process.exitValue() == 0) ExecutionResult(true, output.ifBlank { "Command executed successfully." }, output)
            else ExecutionResult(false, "Exit code ${process.exitValue()}: $output", output)
        } catch (e: IOException) {
            ExecutionResult(false, e.message ?: "Failed to run shell command")
        } catch (e: InterruptedException) {
            ExecutionResult(false, "Command timed out: ${e.message}")
        }
    }

    private fun performWebSearch(query: String): ExecutionResult {
        val apiKey = config.loadSearchApiKey()
        val engineId = config.loadSearchEngineId()

        if (apiKey.isNullOrBlank() || engineId.isNullOrBlank()) {
            return ExecutionResult(
                false,
                "Web search is not configured. Please use 'geministrator config --search-api-key YOUR_KEY --search-engine-id YOUR_ID' to set it up."
            )
        }

        logger.info("  [CLI Adapter] Performing web search for: '$query'")

        try {
            val encodedQuery = URLEncoder.encode(query, "UTF-8")
            val url =
                URI("https://www.googleapis.com/customsearch/v1?key=$apiKey&cx=$engineId&q=$encodedQuery").toURL()
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            connection.setRequestProperty("Accept", "application/json")

            return if (connection.responseCode == HttpURLConnection.HTTP_OK) {
                val responseText = connection.inputStream.bufferedReader().readText()
                val searchResponse = jsonParser.decodeFromString<SearchResponse>(responseText)
                val summary = searchResponse.items.joinToString("\n---\n") {
                    "Title: ${it.title}\nSnippet: ${it.snippet}\nURL: ${it.link}"
                }.ifBlank { "No relevant search results found." }
                ExecutionResult(true, summary)
            } else {
                val error = connection.errorStream.bufferedReader().readText()
                ExecutionResult(
                    false,
                    "Web search failed with status ${connection.responseCode}: $error"
                )
            }
        } catch (e: Exception) {
            return ExecutionResult(false, "An exception occurred during web search: ${e.message}")
        }
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\adapter\CliConfigStorage.kt
====================================================================
package com.hereliesaz.geministrator.adapter

import com.hereliesaz.geministrator.core.config.ConfigStorage
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.util.Properties

class CliConfigStorage : ConfigStorage {
    private val configDir = File(System.getProperty("user.home"), ".gemini-orchestrator")
    private val configFile = File(configDir, "config.properties")
    private val properties = Properties()
    private val KEY_API = "GEMINI_API_KEY"
    private val KEY_REVIEW = "PRE_COMMIT_REVIEW"
    private val KEY_CONCURRENCY = "CONCURRENCY_LIMIT"
    private val KEY_TOKEN_LIMIT = "TOKEN_LIMIT"
    private val KEY_MODEL_STRATEGIC = "MODEL_STRATEGIC"
    private val KEY_MODEL_FLASH = "MODEL_FLASH"
    private val KEY_SEARCH_API = "SEARCH_API_KEY"
    private val KEY_SEARCH_ENGINE_ID = "SEARCH_ENGINE_ID"
    private val KEY_AUTH_METHOD = "AUTH_METHOD"
    private val KEY_FREE_TIER_ONLY = "FREE_TIER_ONLY"


    init {
        configDir.mkdirs()
        if (configFile.exists()) { FileInputStream(configFile).use { properties.load(it) } }
    }

    fun getConfigDirectory(): File = configDir

    private fun saveProperties() { FileOutputStream(configFile).use { properties.store(it, "Gemini Orchestrator Configuration") } }
    override fun saveApiKey(apiKey: String) { properties.setProperty(KEY_API, apiKey); saveProperties() }
    override fun loadApiKey(): String? = properties.getProperty(KEY_API)
    override fun savePreCommitReview(enabled: Boolean) { properties.setProperty(KEY_REVIEW, enabled.toString()); saveProperties() }
    override fun loadPreCommitReview(): Boolean = properties.getProperty(KEY_REVIEW, "true").toBoolean()
    override fun saveConcurrencyLimit(limit: Int) { properties.setProperty(KEY_CONCURRENCY, limit.toString()); saveProperties() }
    override fun loadConcurrencyLimit(): Int = properties.getProperty(KEY_CONCURRENCY, "2").toIntOrNull() ?: 2
    override fun saveTokenLimit(limit: Int) { properties.setProperty(KEY_TOKEN_LIMIT, limit.toString()); saveProperties() }
    override fun loadTokenLimit(): Int = properties.getProperty(KEY_TOKEN_LIMIT, "500000").toIntOrNull() ?: 500000
    override fun saveModelName(type: String, name: String) { properties.setProperty(if (type == "strategic") KEY_MODEL_STRATEGIC else KEY_MODEL_FLASH, name); saveProperties() }
    override fun loadModelName(type: String, default: String): String = properties.getProperty(if (type == "strategic") KEY_MODEL_STRATEGIC else KEY_MODEL_FLASH, default)

    override fun saveSearchApiKey(apiKey: String) {
        properties.setProperty(KEY_SEARCH_API, apiKey); saveProperties()
    }

    override fun loadSearchApiKey(): String? = properties.getProperty(KEY_SEARCH_API)
    override fun saveSearchEngineId(id: String) {
        properties.setProperty(KEY_SEARCH_ENGINE_ID, id); saveProperties()
    }

    override fun loadSearchEngineId(): String? = properties.getProperty(KEY_SEARCH_ENGINE_ID)

    override fun saveAuthMethod(method: String) {
        properties.setProperty(KEY_AUTH_METHOD, method); saveProperties()
    }

    override fun loadAuthMethod(): String =
        properties.getProperty(KEY_AUTH_METHOD, "adc") // Default to adc

    override fun saveFreeTierOnly(enabled: Boolean) {
        properties.setProperty(KEY_FREE_TIER_ONLY, enabled.toString()); saveProperties()
    }

    override fun loadFreeTierOnly(): Boolean =
        properties.getProperty(KEY_FREE_TIER_ONLY, "false").toBoolean()
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\adapter\SearchModels.kt
====================================================================
package com.hereliesaz.geministrator.adapter

import kotlinx.serialization.Serializable

@Serializable
data class SearchResponse(
    val items: List<SearchItem> = emptyList(),
)

@Serializable
data class SearchItem(
    val title: String? = null,
    val link: String? = null,
    val snippet: String? = null,
)


====================================================================
FILE: .\cli\src\main\res\prompts.json
====================================================================
{
    "antagonist.reviewPlan": "You are The Antagonist, a cynical but brilliant principal engineer. Your only goal is to find flaws in proposed plans.\nCritique the following workflow plan. Look for missing steps (especially testing), inefficiencies, or potential risks.\nIf you find a critical flaw, respond with \"OBJECTION: [Your reason]\".\nIf the plan is sound, respond with \"APPROVE\".\n\nPROPOSED PLAN (in JSON):\n{{planJson}}",
    "architect.getProjectContext": "You are an expert software architect. Your job is to identify the most relevant files for a given task. From the following file tree, list the 3-5 most critical files needed to accomplish the task. Respond with ONLY a comma-separated list of file paths.\n\nFILE TREE:\n{{fileTree}}\n\nTASK: \"{{task}}\"",
    "architect.reviewStagedChanges": "You are The Architect, an expert on software architecture. The following code changes have been proposed. Review them for any potential violations of clean architecture principles, unintended side effects, or major flaws. Respond with \"APPROVE\" if the changes are acceptable, or \"REJECT: [reason]\" if they are not.\n\nPROPOSED CHANGES:\n{{changes}}\n\nYour decision:",
    "orchestrator.deconstructPrompt": "You are an expert project manager. Deconstruct the following high-level user request into a series of smaller, parallelizable sub-tasks. You MUST identify dependencies between tasks.\n\nYour response MUST be ONLY a single, valid JSON object of the format:\n{ \"sub_tasks\": [ { \"description\": \"...\", \"responsible_component\": \"...\", \"depends_on\": [1, 2] } ] }\nThe `depends_on` field should contain a list of indices of tasks that must be completed before this one.\nTasks with no dependencies should have an empty `depends_on` list.\n\nPROJECT TYPE: {{projectType}}\n\nUSER REQUEST: \"{{userPrompt}}\"\n\n{{specFileContent}}",
    "orchestrator.generatePlan": "You are an expert software development orchestrator. You will be given a user's request and rich context, including the full content of relevant files.\nYour task is to create a precise, step-by-step workflow plan to accomplish the request.\nYour plan must be in a single, valid JSON object.\n\nIMPORTANT:\n- Your response MUST be only the JSON object, with no other text, comments, or markdown.\n- When modifying a file, your `WRITE_FILE` command must contain the *entire* new content of the file.\n- For `RUN_SHELL`, the `command` parameter MUST be a JSON array of strings (e.g., [\"./gradlew\", \"build\"]). Do not use shell operators like && or |; create separate steps.\n- For `STAGE_FILES`, the `paths` parameter MUST be a JSON array of file path strings.\n- If you modify code, you MUST include a `RUN_TESTS` step before the `STAGE_FILES` step.\n- If the provided context is insufficient, your ONLY step should be a `REQUEST_CLARIFICATION` command.\n- If no changes are needed, provide an empty `steps` array and explain why in the `reasoning`.\n- You can use the `PauseAndExit` command to strategically halt execution and schedule a check-in with the user.\n\nCONTEXT PROVIDED:\n{{context}}\n\nBased on the user's request and all the provided file content and context, create the JSON workflow plan.\n\nUser Request: \"{{userPrompt}}\"",
    "orchestrator.triageTask": "You are a fast and efficient task triage agent. Your sole purpose is to determine what resources are needed for a given software development task. Look at the task description and respond with ONLY a single, valid JSON object. Do not add any other text or markdown.\n\nThe JSON object should have two boolean keys:\n- `needs_web_research`: Set to true if the task requires searching for external libraries, APIs, documentation, or best practices.\n- `needs_project_context`: Set to true if the task requires understanding the existing project files, code structure, or architecture.\n\nTASK: \"{{task}}\"",
    "researcher.findBestPractices": "You are a Senior Staff Engineer. Based on the following web search results, summarize the current best practices for the topic.\n\nSEARCH RESULTS:\n{{searchResults}}\n\nTOPIC: \"{{topic}}\"",
    "techSupport.analyzeMergeConflict": "You are a Tech Support specialist for a team of AI agents. The following 'git merge' command failed. Analyze the conflict output and explain the root cause. Propose a clear, step-by-step strategy for how another AI agent could resolve this conflict.\n\nCONFLICT OUTPUT:\n{{conflictOutput}}\n\nYour analysis and resolution plan:",
    "geminiService.summarizeSession": "Summarize the key points and context of the following conversation to preserve memory for a new session:\n\n{{historyText}}"
}


====================================================================
FILE: .\app_android\build.gradle.kts
====================================================================
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.hereliesaz.geministrator.android"
    compileSdk = 36

    defaultConfig {
        applicationId = "com.hereliesaz.geministrator.android"
        minSdk = 26
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }
    kotlinOptions {
        jvmTarget = "21"
    }
    buildFeatures {
        viewBinding = true
    }
}

dependencies {
    // Project Modules
    // implementation(project(":cli")) // If common logic is extracted

    // Core Android dependencies
    implementation("androidx.core:core-ktx:1.13.1")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("com.google.android.material:material:1.12.0")
    implementation("androidx.constraintlayout:constraintlayout:2.1.4")

    // Testing dependencies
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
}


====================================================================
FILE: .\app_android\resources\META-INF\plugin.xml
====================================================================
<idea-plugin>
    <id>com.hereliesaz.geministrator_plugin</id>
    <name>Geministrator</name>
    <version>1.0.0</version>
    <vendor>hereliesaz</vendor>
    <description><![CDATA[AI-driven development assistant to automate complex workflows.]]></description>
    <depends>com.intellij.modules.platform</depends>
    <depends>org.jetbrains.kotlin</depends>
    <depends>com.intellij.modules.vcs</depends>
    <depends>com.intellij.diff</depends>
    <extensions defaultExtensionNs="com.intellij">
        <toolWindow anchor="right" factoryClass="com.hereliesaz.geministrator_plugin.plugin.OrchestratorToolWindowFactory"
            icon="AllIcons.General.User"
            id="Geministrator" />
    </extensions>
    <actions>
        <action class="com.hereliesaz.geministrator_plugin.plugin.RunOrchestratorAction"
            description="Opens the Geministrator tool window."
            icon="AllIcons.Actions.Execute" id="Geministrator.Run"
            text="Run Geministrator">
            <add-to-group group-id="ToolsMenu" anchor="last"/>
        </action>
    </actions>
</idea-plugin>


====================================================================
FILE: .\app_android\src\build.gradle.kts
====================================================================
plugins {
    id("org.jetbrains.kotlin.jvm")
    id("org.jetbrains.intellij")
    id("org.jetbrains.kotlin.plugin.serialization")
}

sourceSets.main {
    java.srcDirs("src")
    resources.srcDirs("resources")
}


intellij {
    version.set("2023.3.6")
    type.set("IC") // Or "IU" for Ultimate
}

dependencies {
    // FIX: Add the external libraries that the plugin uses via the :core module.
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")

    // Your existing project dependencies are correct.
    implementation(project(":core"))
    implementation(project(":common"))
}

tasks.getByName<org.jetbrains.intellij.tasks.PatchPluginXmlTask>("patchPluginXml") {
    changeNotes.set("Initial stable release.")
}


====================================================================
FILE: .\app_android\src\main\kotlin\com\hereliesaz\geministrator_plugin\adapter\AndroidStudioAdapter.kt
====================================================================
package com.hereliesaz.geministrator_plugin.adapter

import com.hereliesaz.geministrator.common.*
import com.hereliesaz.geministrator.core.council.ILogger
import com.hereliesaz.geministrator.core.config.ConfigStorage
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.Messages
import com.intellij.openapi.vfs.VfsUtil
import org.gradle.api.Project
import java.io.File
import com.intellij.ide.util.PropertiesComponent

private val intellij: Any

class AndroidStudioAdapter(private val project: Project, private val logger: ILogger) : ExecutionAdapter {
    override fun execute(command: AbstractCommand): ExecutionResult {
        var result: ExecutionResult? = null
        ApplicationManager.getApplication().invokeAndWait {
            result = when (command) {
                is AbstractCommand.ReadFile -> {
                    try {
                        val file = VfsUtil.findFileByIoFile(File(project.basePath, command.path), false)
                        val content = file?.let { VfsUtil.loadText(it) } ?: ""
                        ExecutionResult(true, "Read file.", content)
                    } catch (e: Exception) { ExecutionResult(false, "Failed to read file: ${e.message}") }
                }
                is AbstractCommand.RequestCommitReview -> {
                    // This is a simplified version. A real implementation would be more complex.
                    val userChoice = Messages.showYesNoDialog(project, "Approve changes for commit?\nMessage: ${command.proposedCommitMessage}", "Final Review", "Approve", "Reject", null)
                    val decision = if (userChoice == Messages.YES) "APPROVE" else "REJECT"
                    ExecutionResult(true, "User chose '$decision'", decision)
                }
                // This is a simplified adapter. A full implementation would use the IntelliJ SDK
                // for every single command (Git, file I/O, etc.) for maximum safety and integration.
                else -> ExecutionResult(true, "Simulated execution of ${command::class.simpleName} in IDE", null)
            }
        }
        return result ?: ExecutionResult(false, "Adapter command failed to execute on EDT.")
    }
}


====================================================================
FILE: .\app_android\src\main\kotlin\com\hereliesaz\geministrator_plugin\plugin\OrchestratorToolWindowFactory.kt
====================================================================
package com.hereliesaz.geministrator_plugin.plugin

import com.hereliesaz.geministrator.core.GeminiService
import com.hereliesaz.geministrator.core.Orchestrator
import com.hereliesaz.geministrator.core.council.ILogger
import com.hereliesaz.geministrator_plugin.adapter.AndroidStudioAdapter
import com.hereliesaz.geministrator_plugin.adapter.PluginConfigStorage
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.Messages
import com.intellij.openapi.wm.ToolWindow
import com.intellij.openapi.wm.ToolWindowFactory
import com.intellij.ui.components.JBCheckBox
import com.intellij.ui.components.JBScrollPane
import com.intellij.ui.components.JBTextArea
import com.intellij.ui.content.ContentFactory
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.awt.BorderLayout
import java.awt.FlowLayout
import javax.swing.*

class OrchestratorToolWindowFactory : ToolWindowFactory {
    private val coroutineScope = CoroutineScope(Dispatchers.Default)

    override fun createToolWindowContent(project: Project, toolWindow: ToolWindow) {
        val orchestratorPanel = OrchestratorPanel(project)
        val content = ContentFactory.getInstance().createContent(orchestratorPanel, "", false)
        toolWindow.contentManager.addContent(content)
    }

    inner class OrchestratorPanel(private val project: Project) : JPanel(BorderLayout()) {
        private val promptArea = JBTextArea(5, 50).apply {
            lineWrap = true
            wrapStyleWord = true
        }
        private val runButton = JButton("Run Workflow")
        private val outputArea = JTextArea().apply {
            isEditable = false
            font = font.deriveFont(12f)
        }
        private val configStorage = PluginConfigStorage()
        private val logger = ProgressLogger(outputArea)
        private val reviewCheckbox = JBCheckBox("Require final review before commit", configStorage.loadPreCommitReview())
        private val concurrencyLabel = JLabel("Max Parallel Tasks:")
        private val concurrencySpinner = JSpinner(SpinnerNumberModel(configStorage.loadConcurrencyLimit(), 1, 16, 1))
        private val tokenLimitLabel = JLabel("Token Limit:")
        private val tokenLimitSpinner = JSpinner(SpinnerNumberModel(configStorage.loadTokenLimit(), 10000, 2000000, 10000))
        private val monitorLabel = JLabel("Active Task Monitor")
        private val monitorArea = JTextArea(10, 50).apply {
            isEditable = false
            font = font.deriveFont(12f)
        }

        init {
            val settingsPanel = JPanel(FlowLayout(FlowLayout.LEFT))
            settingsPanel.add(reviewCheckbox)
            settingsPanel.add(Box.createHorizontalStrut(10))
            settingsPanel.add(concurrencyLabel)
            settingsPanel.add(concurrencySpinner)
            settingsPanel.add(Box.createHorizontalStrut(10))
            settingsPanel.add(tokenLimitLabel)
            settingsPanel.add(tokenLimitSpinner)

            val buttonPanel = JPanel(BorderLayout())
            buttonPanel.add(runButton, BorderLayout.CENTER)
            buttonPanel.add(settingsPanel, BorderLayout.SOUTH)

            val topPanel = JPanel(BorderLayout())
            topPanel.add(JBScrollPane(promptArea), BorderLayout.CENTER)
            topPanel.add(buttonPanel, BorderLayout.SOUTH)

            val mainPanel = JPanel(BorderLayout())
            mainPanel.add(topPanel, BorderLayout.NORTH)
            mainPanel.add(JBScrollPane(outputArea), BorderLayout.CENTER)

            val monitorPanel = JPanel(BorderLayout())
            monitorPanel.border = BorderFactory.createEmptyBorder(5, 0, 0, 0)
            monitorPanel.add(monitorLabel, BorderLayout.NORTH)
            monitorPanel.add(JBScrollPane(monitorArea), BorderLayout.CENTER)

            val splitPane = JSplitPane(JSplitPane.VERTICAL_SPLIT, mainPanel, monitorPanel)
            splitPane.resizeWeight = 0.7

            add(splitPane, BorderLayout.CENTER)

            runButton.addActionListener {
                coroutineScope.launch { runWorkflow(promptArea.text) }
            }
            reviewCheckbox.addActionListener { configStorage.savePreCommitReview(reviewCheckbox.isSelected) }
            concurrencySpinner.addChangeListener { configStorage.saveConcurrencyLimit(concurrencySpinner.value as Int) }
            tokenLimitSpinner.addChangeListener { configStorage.saveTokenLimit(tokenLimitSpinner.value as Int) }

            if (configStorage.loadApiKey().isNullOrBlank()) {
                showOnboardingWizard()
            }
        }

        private fun showOnboardingWizard() {
            SwingUtilities.invokeLater {
                Messages.showMessageDialog(project, "Welcome to Geministrator!\nThis tool requires a Gemini API Key to function.\nPlease enter your key to continue.", "Welcome", Messages.getInformationIcon())
                coroutineScope.launch { getAndValidateApiKey() }
            }
        }

        private suspend fun runWorkflow(prompt: String) {
            if (prompt.isBlank()) return
            withContext(Dispatchers.Main) {
                outputArea.text = ""
                monitorArea.text = ""
                runButton.isEnabled = false
            }
            val combinedLogger = object : ILogger {
                override fun log(message: String) {
                    logger.log(message)
                    if (message.contains("[STARTING]") || message.contains("[FINISHED]")) {
                        SwingUtilities.invokeLater { monitorArea.append("$message\n") }
                    }
                }
            }
            combinedLogger.log("‚ñ∂Ô∏è Initializing workflow...")
            val apiKey = getAndValidateApiKey()
            if (apiKey == null) {
                combinedLogger.log("‚ùå Workflow cancelled. API key is required.")
                withContext(Dispatchers.Main) { runButton.isEnabled = true }
                return
            }
            val adapter = AndroidStudioAdapter(project, combinedLogger)
            val orchestrator = Orchestrator(adapter, apiKey, combinedLogger, configStorage)
            try {
                orchestrator.run(prompt, project.basePath ?: ".")
            } catch (e: Exception) {
                combinedLogger.log("---")
                combinedLogger.log("‚ùå A critical error occurred: ${e.message}")
            } finally {
                combinedLogger.log("--- Workflow Finished ---")
                withContext(Dispatchers.Main) { runButton.isEnabled = true }
            }
        }

        private suspend fun getAndValidateApiKey(): String? {
            var apiKey = configStorage.loadApiKey()
            while (true) {
                if (!apiKey.isNullOrBlank()) {
                    val service = GeminiService(apiKey, logger, configStorage, "", "")
                    if (service.validateApiKey()) {
                        return apiKey
                    }
                    logger.log("‚ö†Ô∏è Your saved API key is no longer valid. Please enter a new one.")
                }
                apiKey = withContext(Dispatchers.Main) {
                    Messages.showInputDialog(project, "Please enter your Gemini API Key:", "API Key Required", Messages.getQuestionIcon())
                }
                if (apiKey.isNullOrBlank()) return null
                val service = GeminiService(apiKey, logger, configStorage, "", "")
                if (service.validateApiKey()) {
                    configStorage.saveApiKey(apiKey)
                    logger.log("‚úÖ API Key is valid and has been saved.")
                    return apiKey
                } else {
                    withContext(Dispatchers.Main) {
                        Messages.showErrorDialog(project, "The key you entered is invalid. Please try again.", "Invalid API Key")
                    }
                }
            }
        }
    }
}


====================================================================
FILE: .\app_android\src\main\kotlin\com\hereliesaz\geministrator_plugin\plugin\RunOrchestratorAction.kt
====================================================================
package com.hereliesaz.geministrator_plugin.plugin

import com.intellij.openapi.actionSystem.AnAction
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.wm.ToolWindowManager

class RunOrchestratorAction : AnAction() {
    override fun actionPerformed(e: AnActionEvent) {
        val project = e.project ?: return
        val toolWindow = ToolWindowManager.getInstance(project).getToolWindow("Geministrator")
        toolWindow?.show()
    }
}


====================================================================
FILE: .\app_android\src\main\kotlin\com\hereliesaz\geministrator_plugin\plugin\ProgressLogger.kt
====================================================================
package com.hereliesaz.geministrator_plugin.plugin

import com.hereliesaz.geministrator.core.council.ILogger
import com.intellij.openapi.application.ApplicationManager
import javax.swing.JTextArea

class ProgressLogger(private val outputArea: JTextArea) : ILogger {
    override fun log(message: String) {
        ApplicationManager.getApplication().invokeLater {
            outputArea.append("$message\n")
            outputArea.caretPosition = outputArea.document.length
        }
    }
}


====================================================================
FILE: .\plugin_android_studio\build.gradle.kts
====================================================================
plugins {
    id("org.jetbrains.kotlin.jvm")
    id("org.jetbrains.intellij")
}

repositories {
    mavenCentral()
}

// For a detailed guide, see:
// https://github.com/JetBrains/gradle-intellij-plugin/
intellij {
    version.set("2024.1.4") // Target IDE version
    type.set("IC") // Community Edition. Use "IU" for Ultimate.
    plugins.set(listOf("org.jetbrains.kotlin"))
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions.jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)
}

tasks.getByName<org.jetbrains.intellij.tasks.PatchPluginXmlTask>("patchPluginXml") {
    changeNotes.set("""
        ### 0.1.0
        - Initial release of the Geministrator plugin.
    """.trimIndent())
}


====================================================================
FILE: .\plugin_vscode\.vscodeignore
====================================================================


====================================================================
FILE: .\plugin_vscode\package.json
====================================================================
{
  "name": "geministrator",
  "displayName": "Geministrator",
  "description": "An AI-powered development assistant built on a team of collaborative agents.",
  "version": "1.0.0",
  "publisher": "hereliesaz",
  "engines": {
    "vscode": "^1.80.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onCommand:geministrator.start"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "geministrator.start",
        "title": "Start Geministrator",
        "category": "Geministrator"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./"
  },
  "devDependencies": {
    "@types/vscode": "^1.80.0",
    "@types/node": "18.x",
    "typescript": "^5.0.0"
  }
}


====================================================================
FILE: .\plugin_vscode\tsconfig.json
====================================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2020",
    "outDir": "out",
    "lib": [
      "ES2020"
    ],
    "sourceMap": true,
    "rootDir": "src",
    "strict": true
  },
  "exclude": [
    "node_modules",
    ".vscode-test"
  ]
}



====================================================================
FILE: .\plugin_vscode\build.gradle.kts
====================================================================
plugins {
    base
}

// A beautiful crime against nature. We're using Gradle to wrangle a Node.js project.
// Why? Because we can. Because the unity of the build system is a goal in itself,
// however perverse the path to achieving it may be.

description = "Geministrator VSCode Plugin"

// Define paths for the Node project within the Gradle module
val nodeDir = project.projectDir
val vsixDir = layout.buildDirectory.dir("vsix")

// Task to install npm dependencies from package.json
val npmInstall by tasks.registering(Exec::class) {
    group = "VSCode"
    description = "Install Node.js dependencies."
    workingDir = nodeDir
    commandLine("npm", "install")

    inputs.file(file("package.json"))
    inputs.file(file("package-lock.json"))
    outputs.dir(file("node_modules"))
}

// Task to run the VSCode extension packager (vsce)
val vscePackage by tasks.registering(Exec::class) {
    dependsOn(npmInstall)
    group = "VSCode"
    description = "Package the extension into a .vsix file."
    workingDir = nodeDir
    // Assumes vsce is a dev dependency, accessed via npx
    commandLine("npx", "vsce", "package", "--out", vsixDir.get().asFile.absolutePath)

    inputs.dir(file("src"))
    inputs.file(file("package.json"))
    outputs.dir(vsixDir)
}

// The main 'build' task for this module creates the .vsix package
tasks.named("build") {
    dependsOn(vscePackage)
}

// A 'clean' task to remove all generated files
tasks.named("clean", Delete::class) {
    delete(vsixDir)
    delete(file("node_modules"))
    delete(file("out"))
}


====================================================================
FILE: .\plugin_vscode\src\extension.ts
====================================================================
import * as vscode from 'vscode';
import { spawn, ChildProcess } from 'child_process';
import * as path from 'path';

let orchestratorPanel: vscode.WebviewPanel | undefined;
let orchestratorProcess: ChildProcess | undefined;

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('geministrator.start', () => {
            if (orchestratorPanel) {
                orchestratorPanel.reveal(vscode.ViewColumn.Two);
                return;
            }

            orchestratorPanel = vscode.window.createWebviewPanel(
                'geministrator',
                'Geministrator',
                vscode.ViewColumn.Two,
                {
                    enableScripts: true,
                    localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media')]
                }
            );

            orchestratorPanel.webview.html = getWebviewContent();

            orchestratorPanel.onDidDispose(() => {
                orchestratorPanel = undefined;
                if (orchestratorProcess) {
                    orchestratorProcess.kill();
                    orchestratorProcess = undefined;
                }
            }, null, context.subscriptions);

            orchestratorPanel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'runWorkflow':
                            runCliProcess(message.text);
                            return;
                        case 'sendToCli':
                            if (orchestratorProcess && orchestratorProcess.stdin) {
                                orchestratorProcess.stdin.write(`${message.text}\n`);
                            }
                            return;
                    }
                },
                undefined,
                context.subscriptions
            );
        })
    );
}

function runCliProcess(prompt: string) {
    if (orchestratorProcess) {
        orchestratorProcess.kill();
    }

    const cliPath = path.resolve(__dirname, '../../../cli/build/install/cli/bin/cli');

    const args = ['run', prompt];
    orchestratorProcess = spawn(cliPath, args);

    orchestratorProcess.stdout?.on('data', (data: Buffer) => {
        const message = data.toString();
        orchestratorPanel?.webview.postMessage({ command: 'log', text: message });
    });

    orchestratorProcess.stderr?.on('data', (data: Buffer) => {
        const message = data.toString();
        orchestratorPanel?.webview.postMessage({ command: 'log', text: `ERROR: ${message}` });
    });

    orchestratorProcess.on('close', (code) => {
        orchestratorPanel?.webview.postMessage({ command: 'log', text: `\n--- Process finished with exit code ${code} ---` });
        orchestratorProcess = undefined;
    });
}

function getWebviewContent(): string {
    return `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Geministrator</title>
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
                #output { white-space: pre-wrap; background-color: #222; color: #eee; padding: 10px; font-family: monospace; height: 70vh; overflow-y: scroll; border-radius: 5px; }
                textarea { width: 95%; margin-bottom: 10px; }
                button { padding: 5px 10px; }
            </style>
        </head>
        <body>
            <h1>Geministrator</h1>
            <textarea id="prompt" rows="4" placeholder="Enter your high-level task..."></textarea>
            <br>
            <button id="run-button">Run Workflow</button>

            <h3>Output Log</h3>
            <div id="output">Welcome! Enter a prompt and click "Run Workflow" to begin.</div>

            <script>
                const vscode = acquireVsCodeApi();
                const runButton = document.getElementById('run-button');
                const promptArea = document.getElementById('prompt');
                const outputArea = document.getElementById('output');

                runButton.addEventListener('click', () => {
                    const text = promptArea.value;
                    if (text) {
                        outputArea.textContent = ''; // Clear previous output
                        vscode.postMessage({ command: 'runWorkflow', text: text });
                    }
                });

                window.addEventListener('message', event => {
                    const message = event.data;
                    switch (message.command) {
                        case 'log':
                            outputArea.textContent += message.text;
                            outputArea.scrollTop = outputArea.scrollHeight; // Auto-scroll
                            break;
                    }
                });
            </script>
        </body>
        </html>
    `;
}

export function deactivate() {
    if (orchestratorProcess) {
        orchestratorProcess.kill();
    }
}


