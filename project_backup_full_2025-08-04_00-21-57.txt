====================================================================
FILE: .\.gitignore
====================================================================
/cli/build/
/build/



====================================================================
FILE: .\README.md
====================================================================
# Geministrator

**An AI-powered development assistant built on a team of collaborative agents.**

---

## ü§ñ Key Capabilities

- **Autonomous Workflows**: Deconstruct high-level tasks (e.g., "add user authentication") into a
  detailed, multi-step execution plan.
- **Agent-Based Architecture**: A council of specialized AI agents (Architect, Researcher,
  Antagonist) collaborate to plan, execute, and self-correct development tasks.
- **Intelligent Task Triage**: Automatically determines which specialists are needed for a given
  task, conserving resources and tokens for simple requests.
- **Persistent & Resumable Sessions**: Workflows are saved automatically. If a session is paused,
  fails, or requires user input, it can be resumed seamlessly.
- **Git Integration**: Automatically creates feature branches, commits work-in-progress, and
  integrates completed tasks back into the main branch.
- **Configurable & Malleable**: Agent behavior is defined in external JSON, allowing you to
  customize their core instructions without recompiling.
- **Dual Authentication**: Supports both Google Cloud's Application Default Credentials (ADC) for
  potential free-tier access and traditional API keys.
- **Free-Tier Mode**: Can be configured to exclusively use free-tier models and ADC authentication
  to avoid unexpected costs.

---

## üèóÔ∏è Architecture: The Council of Agents

Geministrator operates not as a single monolithic AI, but as a team of specialists with distinct
roles, managed by a central Orchestrator. This approach allows for more robust and nuanced
problem-solving.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Orchestrator   ‚îÇ ‚Üê You interact here. Manages the master plan.
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ Deploys agents based on a triage assessment
         ‚îÇ
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 F‚îÇ      Manager     ‚îÇ ‚Üê Executes the step-by-step workflow for a single task
 E‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 A‚îÇ    Architect     ‚îÇ ‚Üê Analyzes existing code to provide context
 T‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 U‚îÇ    Researcher    ‚îÇ ‚Üê Scours the web for best practices and documentation
 R‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 E‚îÇ     Designer     ‚îÇ ‚Üê Creates specifications and updates changelogs
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 B‚îÇ    Antagonist    ‚îÇ ‚Üê Critiques plans to find flaws before execution
 R‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 A‚îÇ   Tech Support   ‚îÇ ‚Üê Analyzes merge conflicts and other technical failures
 N‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 C         ‚îÇ
 H         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ExecutionAdapter ‚îÇ ‚Üê Interacts with the shell, file system, and Git
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üöÄ Getting Started

### Prerequisites

* **Java 21+**: Ensure a JDK is installed and the `JAVA_HOME` environment variable is set.
* **(Optional) Google Cloud SDK**: For ADC authentication (recommended), install and configure
  `gcloud`. Run `gcloud auth application-default login` to set up your credentials.

### Installation

1. **Build the Installer:**
   From the root of the project, run the `jpackage` Gradle task. This will create a native installer
   in the `cli/build/installer/` directory.
    ```bash
    ./gradlew :cli:jpackage
    ```

2. **Install the Application:**
   Navigate to `cli/build/installer/` and run the generated installer (e.g.,
   `Geministrator-1.0.0.msi` on Windows or the equivalent `.deb`/`.rpm`/`.pkg` on other systems).

3. **Run from Anywhere:**
   After installation, the `geministrator` command will be available on your system's PATH. You can
   run it from any terminal.

---

## ‚öôÔ∏è Configuration

The first time you run the application, it will create a configuration directory at
`~/.gemini-orchestrator/`. You can manage settings via the `config` command.

### Authentication: ADC vs. API Key

Geministrator supports two authentication methods. By default, it will try to use **Application
Default Credentials (ADC)** by shelling out to `gcloud`. If this fails, it will fall back to using a
standard **API Key**.

* **To set your preferred method:**
  ```bash
  # Prioritize gcloud authentication (default)
  geministrator config --auth-method adc

  # Use a manually provided API key
  geministrator config --auth-method apikey
  ```

### Completely Free Tier Mode

You can enforce the use of free-tier models and ADC authentication to prevent accidental charges. If
ADC is not configured, Geministrator will refuse to run in this mode.

* **To enable or disable free tier mode:**
  ```bash
  geministrator config --free-tier true
  geministrator config --free-tier false
  ```

### Other Settings

You can configure other operational parameters:

```bash
# Toggle the final user review before committing merged code
geministrator config -r

# Set the number of sub-tasks to run in parallel
geministrator config -c 4

# Set a custom token limit for the AI conversation history
geministrator config -t 700000

# Configure web search credentials (for the Researcher agent)
geministrator config --search-api-key "YOUR_Google Search_API_KEY"
geministrator config --search-engine-id "YOUR_PROGRAMMABLE_SEARCH_ENGINE_ID"
```

---

## üíª Usage

### Running a Workflow

The primary command is `run`. It takes a high-level prompt describing your development task.

```bash
# Run a simple task
geministrator run "Refactor the UserService class to use the new DatabaseWrapper."

# Run a more complex task with a formal specification file
geministrator run "Implement the user profile page" --spec-file "docs/specs/profile_page.md"
```

### Writing a Project Specification

For complex tasks, providing a spec file (inspired
by [Tmux-Orchestrator](https://github.com/a-s-w/tmux-orchestrator)) helps the AI generate a more
accurate master plan.

**Example `profile_page.md`:**
`markdown
PROJECT: My Web App
GOAL: Create a new user profile page.

CONSTRAINTS:

- Use the existing React component library.
- Follow current code patterns for state management.
- The page must be responsive.

DELIVERABLES:

1. A new route at `/profile`.
2. A component to display user information (name, email).
3. A form to update the user's password.
4. All new code must have corresponding unit tests.
   `

### Resuming a Session

If a workflow is paused (e.g., the AI needs clarification) or fails, the session state is saved to
`.orchestrator/session.json`. Simply re-running the original `geministrator run` command in the same
directory will prompt you to resume the workflow from where it left off.

---

## üîß Customizing Agent Behavior

The core instructions and "personality" of each AI agent are not hardcoded. They are stored in a
plain text JSON file located at `~/.gemini-orchestrator/prompts.json`. You can edit this file to
change how the agents behave.

For example, you could make the `Antagonist` more critical or instruct the `Architect` to prefer a
different coding style.

* **To reset all prompts to their original defaults:**
  ```bash
  geministrator config --reset-prompts true
  ```
  This will delete your custom `prompts.json`, and the application will use the default prompts from
  its internal resources on the next run.

---

## üìú License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.


====================================================================
FILE: .\build.gradle.kts
====================================================================
// The root-level plugins block was conflicting with plugin management in settings.gradle.kts.
// It has been removed to centralize plugin versioning.

plugins {
    // The intellij platform plugin is applied here because it's not a standard
    // Android/Kotlin plugin and is best managed at the root level for IDE tooling.
}



====================================================================
FILE: .\settings.gradle.kts
====================================================================
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
        mavenLocal()
        maven("https://jitpack.io")
    }
    plugins {
        id("org.jetbrains.kotlin.jvm") version "2.0.0" apply false
        id("org.jetbrains.kotlin.plugin.serialization") version "2.0.0" apply false
        id("application")
        id("org.panteleyev.jpackageplugin") version "1.7.3"
        id("com.android.application") version "8.12.0" apply false
        id("org.jetbrains.kotlin.plugin.compose") version "2.0.0" apply false
        id("org.jetbrains.intellij.platform") version "2.7.0" apply false
    }
}

dependencyResolutionManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
        mavenLocal()
        maven("https://jitpack.io")
    }
}


rootProject.name = "geministrator"

include(":cli")
include(":app_android")
include(":plugin_android_studio")
include(":plugin_vscode")


====================================================================
FILE: .\gradle.properties
====================================================================
org.gradle.java.home=C:/Users/azrie/.jdks/jbr-17.0.14


====================================================================
FILE: .\LICENSE
====================================================================
Copyright (c) 2025 HereLiesAz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


====================================================================
FILE: .\CHANGELOG.md
====================================================================
# Geministrator Changelog

All notable changes to this project will be documented in this file.

## [1.1.0] - (In Progress)

### Added

- **Android UI Scaffolding**: Created the initial Android application shell using Jetpack Compose
  and Material 3, including themes, navigation graph, and placeholder screens.
- **On-Device Backend Architecture**:
    - Implemented file system access via Android's Storage Access Framework (SAF), allowing users to
      grant persistent, sandboxed access to specific project folders.
    - Integrated the `JGit` pure Kotlin library for on-device version control, enabling programmatic
      `init`, `add`, `commit`, and `status` operations.
- **Project-Centric Workflow**: The app now operates on a user-selected project directory. A setup
  screen guides the user through this one-time selection process.
- **Live Data Integration**: Replaced simulated session data with a live, interactive workflow. The
  `SessionViewModel` now uses the `ProjectViewModel` to perform real file and Git operations based
  on a simulated agent task list.
- **Rich Content Display**: Session logs have been enhanced to render markdown, formatted code
  blocks with custom backgrounds, and shimmering placeholder components to indicate loading states.
- **UI Components**:
    - Added a functional `NavRail` using `NavigationSuiteScaffold` for primary app navigation
      between Sessions, Settings, and History.
    - Implemented a "New Session" dialog to capture a user's high-level prompt before initiating a
      workflow.

## [1.0.0] - 2025-08-03

### Added

- **Core Agent Logic**: Initial implementation of the `Orchestrator` and the council of AI agents (
  `Architect`, `Designer`, `Antagonist`, `Researcher`, `Manager`, `TechSupport`).
- **Command-Line Interface (CLI)**:
    - Created the primary CLI application in the `:cli` module for running development workflows
      from the terminal.
    - Implemented configuration management in the user's home directory (`~/.gemini-orchestrator`).
    - Added support for both Google Cloud ADC and manual API Key authentication methods.
- **Multi-Module Gradle Project**:
    - Set up the initial project structure with `settings.gradle.kts` and root `build.gradle.kts`.
    - Added modules for an Android App (`:app_android`), Android Studio Plugin (
      `:plugin-android-studio`), and VSCode Extension (`:plugin-vscode`).
- **Plugin Scaffolding**:
    - Created basic build scripts and UI shells for the Android Studio and VSCode plugins.
    - Established the architecture where plugins depend on the `:cli` module as a shared library.

---

## TODO

### Core Logic & On-Device Backend

- [ ] **Full `Orchestrator` Integration**
    - [ ] Replace the hardcoded workflow in `SessionViewModel` with a call to the real
      `Orchestrator` instance from the `:cli` module.
    - [ ] Create a `ViewModel`-safe `ExecutionAdapter` for Android that uses the `ProjectManager`
      for file operations.
    - [ ] Implement a `Flow`-based `ILogger` that the `Orchestrator` can use to stream log entries
      back to the `SessionViewModel` in real-time.
    - [ ] Pass the on-device `GitManager` to the `Orchestrator`'s `ExecutionAdapter` to handle
      version control commands.
- [ ] **Robust Error Handling**
    - [ ] In `ProjectManager`, add detailed `try-catch` blocks for all SAF file operations to handle
      `FileNotFoundException`, `IOException`, etc.
    - [ ] In `GitManager`, wrap all `JGit` calls in `try-catch` blocks to handle exceptions like
      `NoHeadException`, `GitAPIException`, etc.
    - [ ] Propagate errors gracefully to the UI, displaying user-friendly messages in the session
      log (e.g., using a new `LogEntry` type for errors).
- [ ] **SAF-to-File Path Resolution**
    - [ ] Implement a reliable mechanism to translate a SAF `Uri` to a real `File` path that `JGit`
      can use directly, likely by copying the repository to the app's internal cache directory and
      syncing changes.
- [ ] **GitHub Integration**
    - [ ] Add a new `GitHubManager` class to the `data` package.
    - [ ] Integrate a GitHub API client library (e.g., `kotlin-github-api`).
    - [ ] Implement OAuth for user authentication with GitHub.
    - [ ] Add methods for `createPullRequest`, `listIssues`, and `createIssue`.
    - [ ] Connect these methods to new `AbstractCommand`s that the `Orchestrator` can generate.

### Android App UI/UX

- [ ] **Settings Screen**
    - [ ] Design the UI layout for managing settings.
    - [ ] Create a `SettingsViewModel` to load and save preferences.
    - [ ] Add a field for the user to input and save their Gemini API key.
    - [ ] Implement UI for changing the color theme.
    - [ ] Add a section to view and edit the JSON prompts used by the AI agents.
- [ ] **History Screen**
    - [ ] Design a UI to display a list of completed sessions.
    - [ ] Implement persistence for session logs (e.g., using Room database).
    - [ ] Allow users to tap on a past session to view its full log.
- [ ] **Git UI Integration**
    - [ ] Create a "Version Control" tab or panel within the `SessionScreen`.
    - [ ] Display the output of `git status` in a formatted way.
    - [ ] Add a "Staged Files" section with checkboxes, allowing the user to manually stage or
      unstage files.
    - [ ] Implement a `git diff` viewer to show changes in a selected file.
- [ ] **File Browser**
    - [ ] Create a new "Explorer" screen accessible from the `NavRail`.
    - [ ] Display a navigable tree of the files and directories within the user-selected project
      folder.
    - [ ] Allow users to tap on a file to view its content in a read-only editor.
- [ ] **Real-time Sync & UI State**
    - [ ] Convert `SessionViewModel` to emit a `UiState` object containing the log entries, current
      agent status, etc., to better manage loading and result states.
    - [ ] Refactor the `Orchestrator`'s `ILogger` to emit structured `LogEntry` objects instead of
      raw strings to the `Flow`.

### Plugins

- [ ] **VSCode Backend Service**
    - [ ] Define the specific REST/WebSocket API endpoints needed (e.g., `/run`, `/status`,
      `/ws/logs`).
    - [ ] Choose a framework (Ktor, Spring Boot) and implement the server.
    - [ ] The server must be able to launch the `Orchestrator` from the `:cli` module as a child
      process or library call.
    - [ ] Update the `extension.ts` in `:plugin-vscode` to communicate with this local server
      instead of spawning the CLI directly.
- [ ] **Plugin Feature Parity**
    - [ ] Implement the `NewSessionDialog` equivalent in the Android Studio plugin UI.
    - [ ] Ensure the Android Studio plugin can display markdown, code blocks, and placeholders.
    - [ ] Replicate the `NavRail` functionality (Sessions, Settings, History) in the Android Studio
      plugin's tool window.

### Code Quality & Refinements

- [ ] **Unit & Integration Tests**
    - [ ] Write unit tests for `GitManager` using a temporary folder.
    - [ ] Write unit tests for all `ViewModel` state logic.
    - [ ] Add integration tests for the `Orchestrator` running with a mock `ExecutionAdapter`.
- [ ] **Documentation**
    - [ ] Add KDoc comments to all public classes and methods.
    - [ ] Update the main `README.md` to include instructions for setting up and running the Android
      app.
- [ ] **Performance Optimization**
    - [ ] Profile the app during file I/O and Git operations to identify bottlenecks.
    - [ ] Optimize the `LazyColumn` in `SessionScreen` for very long logs.


====================================================================
FILE: .\AndroidLogger.kt
====================================================================


====================================================================
FILE: .\gradle\libs.versions.toml
====================================================================
[versions]
android-gradle-plugin = "8.12.0"
kotlin = "2.0.0"
core-ktx = "1.13.1"
lifecycle = "2.8.1"
activity-compose = "1.9.0"
compose-bom = "2024.05.00"
navigation-compose = "2.7.7"
jgit = "6.9.0.202403050737-r"

junit = "4.13.2"
androidx-test-ext = "1.1.5"
espresso-core = "3.5.1"

[libraries]
# Core & Lifecycle
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "core-ktx" }
androidx-lifecycle-runtime = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycle" }
androidx-lifecycle-viewmodel-compose = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version.ref = "lifecycle" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activity-compose" }

# Compose
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "compose-bom" }
androidx-compose-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-compose-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-compose-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-compose-foundation = { group = "androidx.compose.foundation", name = "foundation" }

# Material 3 & Adaptive
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-material3-window = { group = "androidx.compose.material3", name = "material3-window-size-class" }
androidx-material3-adaptive = { group = "androidx.compose.material3", name = "material3-adaptive" }
androidx-material3-adaptive-navigation-suite = { group = "androidx.compose.material3", name = "material3-adaptive-navigation-suite" }

# Navigation
androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigation-compose" }

# Git
eclipse-jgit = { group = "org.eclipse.jgit", name = "org.eclipse.jgit", version.ref = "jgit"}

# Testing
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-test-ext-junit = { group = "androidx.test.ext", name = "junit", version.ref = "androidx-test-ext" }
androidx-test-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espresso-core" }
androidx-compose-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }

# Debugging
androidx-compose-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-compose-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }

[plugins]
android-application = { id = "com.android.application", version.ref = "android-gradle-plugin" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }


====================================================================
FILE: .\gradle\wrapper\gradle-wrapper.properties
====================================================================
#Sun Aug 03 20:33:25 CDT 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.3-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



====================================================================
FILE: .\cli\build.gradle.kts
====================================================================
import org.panteleyev.jpackage.ImageType
import org.panteleyev.jpackage.JPackageTask
// Module-level build file for the 'app' module.
plugins {
    kotlin("jvm")
    `java-library`
    application
    id("org.jetbrains.kotlin.plugin.serialization")
    id("org.panteleyev.jpackageplugin")
}

group = "com.hereliesaz.geministrator"
version = "1.1.0"

// Add sourceSets block to include resources
sourceSets {
    main {
        resources {
            srcDirs("src/main/resources")
        }
    }
}

repositories {
    mavenCentral()
    google()
    gradlePluginPortal()
    mavenLocal()
    maven("https://jitpack.io")
}

application {
    mainClass.set("com.hereliesaz.geministrator.MainKt")
    applicationName = "geministrator"
}

dependencies {
    // All project dependencies are now here
    implementation("org.jetbrains.kotlinx:kotlinx-cli:0.3.6")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions.jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
}

// This task gathers all dependency JARs into one place for the installer.
val copyDependencies by tasks.registering(Copy::class) {
    from(configurations.runtimeClasspath)
    into(layout.buildDirectory.dir("jpackage-input/libs"))
}

// This task copies your application's own JAR into the installer's input directory.
val copyJar by tasks.registering(Copy::class) {
    from(tasks.jar)
    into(layout.buildDirectory.dir("jpackage-input"))
}

// This configures the jpackage task, which creates the native installer.
tasks.named<JPackageTask>("jpackage") {
    dependsOn(copyDependencies, copyJar)
    appName.set("Geministrator")
    appVersion.set(project.version.toString())
    vendor.set("HereLiesAz")
    copyright.set("Copyright (c) 2025 HereLiesAz")
    mainJar.set(tasks.jar.get().archiveFileName.get())
    // Correctly specify the main class for the launcher
    mainClass.set(application.mainClass.get())

    // Uses the 'type' property with the correct 'ImageType' enum.
    type.set(ImageType.APP_IMAGE)
    // The input directory must contain your app's JAR and a 'libs' folder with all dependencies.
    input.set(layout.buildDirectory.dir("jpackage-input"))
    destination.set(layout.buildDirectory.dir("installer"))
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\Main.kt
====================================================================
package com.hereliesaz.geministrator

import com.hereliesaz.geministrator.adapter.CliAdapter
import com.hereliesaz.geministrator.adapter.CliConfigStorage
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.MultiStreamLogger
import com.hereliesaz.geministrator.common.PromptManager
import com.hereliesaz.geministrator.core.Orchestrator
import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.ExperimentalCli
import kotlinx.cli.Subcommand
import kotlinx.coroutines.runBlocking
import java.io.File

@OptIn(ExperimentalCli::class)
fun main(args: Array<String>) {
    val parser = ArgParser("geministrator")
    val configStorage = CliConfigStorage()
    val logger = MultiStreamLogger(configStorage.getConfigDirectory())
    val promptManager = PromptManager(configStorage.getConfigDirectory())
    val adapter = CliAdapter(configStorage, logger)

    class RunCommand : Subcommand("run", "Run a new workflow") {
        val prompt by argument(ArgType.String, description = "The high-level task for the AI to perform")
        val specFile by option(
            ArgType.String,
            fullName = "spec-file",
            description = "Path to a project specification markdown file."
        )

        override fun execute() {
            runBlocking {
                val geminiService = createGeminiService(configStorage, logger, adapter)
                if (geminiService == null) {
                    logger.error("Could not configure a valid authentication method. Exiting.")
                    return@runBlocking
                }

                val specFileContent = specFile?.let {
                    try {
                        File(it).readText()
                    } catch (e: Exception) {
                        logger.error("Could not read spec file at '$it'.", e)
                        null
                    }
                }

                val projectType = determineProjectType(logger)
                val orchestrator =
                    Orchestrator(adapter, logger, configStorage, promptManager, geminiService)
                orchestrator.run(
                    prompt,
                    System.getProperty("user.dir"),
                    projectType,
                    specFileContent
                )
            }
        }
    }

    class ConfigureCommand : Subcommand("config", "Configure settings") {
        val toggleReview by option(ArgType.Boolean, shortName = "r", description = "Toggle pre-commit review")
        val setConcurrency by option(ArgType.Int, shortName = "c", description = "Set concurrency limit")
        val setTokenLimit by option(ArgType.Int, shortName = "t", description = "Set token limit")
        val setSearchApiKey by option(
            ArgType.String,
            fullName = "search-api-key",
            description = "Set Google Custom Search API Key"
        )
        val setSearchEngineId by option(
            ArgType.String,
            fullName = "search-engine-id",
            description = "Set Google Programmable Search Engine ID"
        )
        val resetPrompts by option(
            ArgType.Boolean,
            fullName = "reset-prompts",
            description = "Reset all agent prompts to their default values"
        )
        val setAuthMethod by option(
            ArgType.String,
            fullName = "auth-method",
            description = "Set the preferred authentication method ('adc' or 'apikey')"
        )
        val setFreeTierOnly by option(
            ArgType.Boolean,
            fullName = "free-tier",
            description = "Toggle free tier only mode (enforces ADC auth and free models)"
        )


        override fun execute() {
            toggleReview?.let {
                val current = configStorage.loadPreCommitReview()
                configStorage.savePreCommitReview(!current)
                logger.interactive("SUCCESS: Pre-commit review set to: ${!current}")
            }
            setConcurrency?.let {
                configStorage.saveConcurrencyLimit(it)
                logger.interactive("SUCCESS: Concurrency limit set to: $it")
            }
            setTokenLimit?.let {
                configStorage.saveTokenLimit(it)
                logger.interactive("SUCCESS: Token limit set to: $it")
            }
            setSearchApiKey?.let {
                configStorage.saveSearchApiKey(it)
                logger.interactive("SUCCESS: Search API Key has been saved.")
            }
            setSearchEngineId?.let {
                configStorage.saveSearchEngineId(it)
                logger.interactive("SUCCESS: Search Engine ID has been saved.")
            }
            resetPrompts?.let {
                if (it) {
                    if (promptManager.resetToDefaults()) {
                        logger.interactive("SUCCESS: Custom prompts file deleted. System will use default prompts on next run.")
                    } else {
                        logger.error("Failed to delete custom prompts file.")
                    }
                }
            }
            setAuthMethod?.let {
                val method = it.lowercase()
                if (method == "adc" || method == "apikey") {
                    configStorage.saveAuthMethod(method)
                    logger.interactive("SUCCESS: Default authentication method set to '$method'.")
                } else {
                    logger.error("Invalid authentication method. Please choose 'adc' or 'apikey'.")
                }
            }
            setFreeTierOnly?.let {
                configStorage.saveFreeTierOnly(it)
                logger.interactive("SUCCESS: Free tier only mode set to '$it'.")
            }
        }
    }

    parser.subcommands(RunCommand(), ConfigureCommand())
    parser.parse(args)
}

private suspend fun createGeminiService(
    configStorage: CliConfigStorage,
    logger: ILogger,
    adapter: CliAdapter,
): GeminiService? {
    val freeTierOnly = configStorage.loadFreeTierOnly()
    val authMethod = if (freeTierOnly) "adc" else configStorage.loadAuthMethod()

    val strategicModel: String
    val flashModel: String

    if (freeTierOnly) {
        logger.info("Free Tier Only mode is enabled. Using free models and ADC authentication.")
        strategicModel = "gemini-1.5-pro-latest"
        flashModel = "gemini-1.5-flash-latest"
    } else {
        strategicModel = configStorage.loadModelName("strategic", "gemini-pro")
        flashModel = configStorage.loadModelName("flash", "gemini-1.5-flash-latest")
    }

    val promptManager = PromptManager(configStorage.getConfigDirectory())

    if (authMethod == "adc") {
        val service = GeminiService(
            authMethod = "adc",
            apiKey = "", // Not needed for ADC
            logger = logger,
            config = configStorage,
            strategicModelName = strategicModel,
            flashModelName = flashModel,
            promptManager = promptManager,
            adapter = adapter
        )
        if (service.isAdcAuthReady()) {
            return service
        }
        if (freeTierOnly) {
            logger.error("Free Tier Only mode requires ADC authentication, which failed. Please configure gcloud or disable free tier mode.")
            return null
        }
        logger.info("ADC authentication failed. Checking for API key as fallback...")
    }

    // Fallback to API key or if 'apikey' is the chosen method
    var apiKey = configStorage.loadApiKey()
    while (true) {
        if (!apiKey.isNullOrBlank()) {
            val serviceForValidation =
                GeminiService("apikey", apiKey, logger, configStorage, "", "", null, null)
            if (serviceForValidation.validateApiKey(apiKey)) {
                logger.info("API Key authentication successful.")
                return GeminiService(
                    "apikey",
                    apiKey,
                    logger,
                    configStorage,
                    strategicModel,
                    flashModel,
                    promptManager,
                    adapter
                )
            }
            logger.error("Your saved API key is no longer valid.")
        }
        apiKey = logger.prompt("Please enter your Gemini API Key: ")
        if (apiKey.isNullOrBlank()) return null
        configStorage.saveApiKey(apiKey)
    }
}


private fun determineProjectType(logger: ILogger): String {
    logger.interactive("\nWhat type of project are you working on?")
    val options = listOf(
        "Application",
        "Web Service/API",
        "Library/SDK",
        "Automation Script",
        "Website",
        "Other"
    )
    options.forEachIndexed { index, option -> logger.interactive("  ${index + 1}. $option") }
    while (true) {
        val choiceStr = logger.prompt("Enter your choice (number): ")
        val choice = choiceStr?.toIntOrNull()
        if (choice != null && choice in 1..options.size) {
            return options[choice - 1]
        }
        logger.error("Invalid selection. Please enter a number from the list.")
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\Manager.kt
====================================================================
package com.hereliesaz.geministrator.core

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ILogger

sealed class WorkflowStatus {
    data class Success(val commitMessage: String, val successfulSteps: List<String>) : WorkflowStatus()
    data class Failure(val reason: String) : WorkflowStatus()
    data class TestsFailed(val testOutput: String, val successfulSteps: List<String>) : WorkflowStatus()
}

class Manager(private val adapter: ExecutionAdapter, private val logger: ILogger) {
    fun executeWorkflow(workflow: List<AbstractCommand>, prompt: String): WorkflowStatus {
        logger.info("Manager starting workflow with ${workflow.size} steps.")
        if (workflow.isEmpty()) {
            logger.info("WARNING: Manager received an empty workflow. Nothing to do.")
            return WorkflowStatus.Success("No changes made.", emptyList())
        }

        val successfulSteps = mutableListOf<String>()
        for (command in workflow) {
            val commandName = command::class.simpleName ?: "UnknownCommand"
            logger.info("---")
            logger.info("  [Manager] -> Delegating command: $commandName")
            val result = adapter.execute(command)

            // If the adapter executes PauseAndExit, the application will terminate,
            // and the code below this line will not be reached.
            if (command is AbstractCommand.PauseAndExit) {
                // This return is effectively unreachable but satisfies the compiler.
                return WorkflowStatus.Success("Workflow paused by user.", successfulSteps)
            }

            if (!result.isSuccess) {
                val reason = "Execution of $commandName failed: ${result.output}"
                logger.error("  ERROR: $reason")

                // If tests failed, we return a specific status for self-correction.
                if (command is AbstractCommand.RunTests) {
                    logger.error("  TESTS FAILED!")
                    return WorkflowStatus.TestsFailed(result.output, successfulSteps)
                }

                return WorkflowStatus.Failure(reason)
            }
            logger.info("  SUCCESS: ${result.output}")
            successfulSteps.add(commandName)
        }

        logger.info("---")
        logger.info("Manager completed workflow successfully.")
        return WorkflowStatus.Success(prompt, successfulSteps)
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\Orchestrator.kt
====================================================================
package com.hereliesaz.geministrator.core

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ExecutionResult
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager
import com.hereliesaz.geministrator.core.config.ConfigStorage
import com.hereliesaz.geministrator.core.council.Antagonist
import com.hereliesaz.geministrator.core.council.Architect
import com.hereliesaz.geministrator.core.council.Designer
import com.hereliesaz.geministrator.core.council.Researcher
import com.hereliesaz.geministrator.core.council.TechSupport
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonPrimitive
import kotlin.system.exitProcess

@Serializable
data class SessionState(
    val masterPlan: MasterPlan,
    val completedBranches: List<String>,
    val completedTaskIndices: Set<Int>, // Explicitly track completed task indices
    val mainBranch: String,
)

@Serializable
data class MasterPlan(val sub_tasks: List<SubTask>)

@Serializable
data class SubTask(
    val description: String,
    val responsible_component: String,
    val depends_on: List<Int> = emptyList(),
)

@Serializable
data class WorkflowPlan(val reasoning: String, val steps: List<WorkflowStep>)

@Serializable
data class WorkflowStep(val command_type: String, val parameters: JsonObject)

@Serializable
private data class TriageResult(
    val needs_web_research: Boolean = false,
    val needs_project_context: Boolean = false,
)


class Orchestrator(
    private val adapter: ExecutionAdapter,
    private val logger: ILogger,
    private val config: ConfigStorage,
    private val promptManager: PromptManager,
    private val ai: GeminiService,
) {
    private val architect: Architect
    private val researcher: Researcher
    private val designer: Designer
    private val antagonist: Antagonist
    private val techSupport: TechSupport
    private val jsonParser = Json { isLenient = true; ignoreUnknownKeys = true }
    private val MAX_RETRY_ATTEMPTS = 2
    private val JOURNAL_FILE = ".orchestrator/journal.log"
    private val SESSION_FILE = ".orchestrator/session.json"

    init {
        architect = Architect(logger, ai, adapter, promptManager)
        researcher = Researcher(logger, ai, adapter, promptManager)
        designer = Designer(logger, adapter)
        antagonist = Antagonist(logger, ai, promptManager)
        techSupport = TechSupport(logger, ai, promptManager)
    }

    fun run(prompt: String, projectRoot: String, projectType: String, specFileContent: String?) =
        runBlocking(Dispatchers.Default) {
            val sessionState = loadSessionState()
            if (sessionState != null) {
                val decision = adapter.execute(
                    AbstractCommand.RequestUserDecision(
                        "An incomplete workflow was found. Do you want to resume it?",
                        listOf("Resume", "Start New")
                    )
                )
                if (decision.data == "Resume") {
                    logger.info("Resuming previous workflow...")
                    executeMasterPlan(
                        sessionState.masterPlan,
                        projectRoot,
                        sessionState.mainBranch,
                        sessionState.completedBranches.toMutableList(),
                        sessionState.completedTaskIndices.toMutableSet()
                    )
                    return@runBlocking
                }
            }

            ai.clearSession()
            logger.info("Orchestrator received complex prompt: '$prompt'")
            val mainBranch = adapter.execute(AbstractCommand.GetCurrentBranch).output.trim()
            val masterPlanJson = deconstructPromptIntoSubTasks(prompt, projectType, specFileContent)
            if (masterPlanJson.startsWith("Error:")) {
                logger.error("CRITICAL: Could not deconstruct prompt into sub-tasks. AI Failure: $masterPlanJson")
                return@runBlocking
            }
            val masterPlan = jsonParser.decodeFromString<MasterPlan>(masterPlanJson)
            saveSessionState(SessionState(masterPlan, emptyList(), emptySet(), mainBranch))
            executeMasterPlan(masterPlan, projectRoot, mainBranch, mutableListOf(), mutableSetOf())
        }

    private suspend fun executeMasterPlan(
        masterPlan: MasterPlan,
        projectRoot: String,
        mainBranch: String,
        completedBranches: MutableList<String>,
        completedIndices: MutableSet<Int>,
    ) = coroutineScope {
        val integrationBranch = "integration/orchestrator-${System.currentTimeMillis()}"
        val concurrencyLimit = config.loadConcurrencyLimit()
        val semaphore = Semaphore(concurrencyLimit)
        logger.info("Orchestrator has deconstructed the prompt into ${masterPlan.sub_tasks.size} sub-tasks.")
        logger.info("Concurrency limit set to $concurrencyLimit simultaneous tasks.")

        val tasks = masterPlan.sub_tasks.withIndex().toList()
        val runningTasks = mutableSetOf<Int>()

        while (completedIndices.size < tasks.size) {
            val tasksReadyToRun = tasks.filter { (index, subTask) ->
                index !in completedIndices &&
                        index !in runningTasks &&
                        subTask.depends_on.all { it in completedIndices }
            }

            if (tasksReadyToRun.isEmpty() && runningTasks.isEmpty() && completedIndices.size < tasks.size) {
                logger.error("EXECUTION HALTED: Circular dependency or failed tasks detected. Cannot proceed.")
                saveSessionState(
                    SessionState(
                        masterPlan,
                        completedBranches,
                        completedIndices,
                        mainBranch
                    )
                )
                return@coroutineScope
            }

            val jobs = tasksReadyToRun.map { (index, subTask) ->
                runningTasks.add(index)
                async {
                    val taskResult = semaphore.withPermit {
                        val taskBranch = "feature/orchestrator-task-$index"
                        logger.info("---")
                        logger.info("[STARTING] Manager for '${subTask.description}' on branch '$taskBranch'")
                        handleTask(subTask.description, projectRoot, mutableListOf(), 0, taskBranch)
                    }
                    if (taskResult != null) {
                        completedBranches.add(taskResult)
                        completedIndices.add(index)
                        saveSessionState(
                            SessionState(
                                masterPlan,
                                completedBranches,
                                completedIndices,
                                mainBranch
                            )
                        )
                    }
                    runningTasks.remove(index)
                    taskResult != null
                }
            }

            val results = jobs.awaitAll()
            if (results.any { !it }) {
                logger.error("One or more tasks failed in the current wave. Halting further execution.")
                saveSessionState(
                    SessionState(
                        masterPlan,
                        completedBranches,
                        completedIndices,
                        mainBranch
                    )
                )
                return@coroutineScope
            }
        }

        logger.info("All sub-tasks completed. Beginning final integration.")
        adapter.execute(AbstractCommand.CreateAndSwitchToBranch(integrationBranch))
        var mergeSuccess = true
        var mergeResult: ExecutionResult? = null
        for (branch in completedBranches) {
            mergeResult = adapter.execute(AbstractCommand.MergeBranch(branch))
            if (!mergeResult.isSuccess) {
                logger.error("CRITICAL: Merge conflict detected when merging '$branch'. Halting integration.")
                mergeSuccess = false
                break
            }
        }

        if (mergeSuccess) {
            val commitMessage =
                "feat: ${masterPlan.sub_tasks.joinToString(", ") { it.description }}"
            if (config.loadPreCommitReview()) {
                val reviewResult =
                    adapter.execute(AbstractCommand.RequestCommitReview(commitMessage))
                if (reviewResult.data != "APPROVE") {
                    logger.info("User rejected the final commit. Rolling back.")
                    cleanup(integrationBranch, completedBranches, mainBranch)
                    return@coroutineScope
                }
            }
            adapter.execute(AbstractCommand.SwitchToBranch(mainBranch))
            adapter.execute(AbstractCommand.MergeBranch(integrationBranch))
            designer.updateChangelog(commitMessage)
            cleanup(integrationBranch, completedBranches, mainBranch)
        } else {
            val analysis = techSupport.analyzeMergeConflict(mergeResult?.output ?: "Unknown error")
            logger.info("--- TECH SUPPORT ANALYSIS ---\n$analysis")
            val userDecision = adapter.execute(
                AbstractCommand.RequestUserDecision(
                    "A merge conflict occurred. What should we do?",
                    listOf("Abandon", "Attempt AI Fix")
                )
            )
            if (userDecision.data == "Attempt AI Fix") {
                handleTask(
                    "Resolve merge conflict based on Tech Support analysis",
                    projectRoot,
                    mutableListOf(analysis),
                    0,
                    integrationBranch,
                    createBranch = false
                )
            } else {
                cleanup(integrationBranch, completedBranches, mainBranch)
            }
        }
    }

    private fun handleTask(prompt: String, projectRoot: String, context: MutableList<String>, attempt: Int, branch: String, createBranch: Boolean = true): String? {
        logJournal("START_TASK", mapOf("prompt" to prompt, "branch" to branch, "attempt" to attempt))

        if (createBranch) {
            adapter.execute(AbstractCommand.CreateAndSwitchToBranch(branch))
        }

        if (attempt > MAX_RETRY_ATTEMPTS) {
            logger.error("Maximum retry attempts reached for task '$prompt'. Halting this sub-task.")
            designer.recordHistoricalLesson("Sub-task '$prompt' failed after $MAX_RETRY_ATTEMPTS self-correction attempts.")
            return null
        }

        if (attempt == 0 && createBranch) {
            val specWorkflow = designer.createSpecification(prompt)
            Manager(adapter, logger).executeWorkflow(specWorkflow, prompt)
        }

        logger.info("Triaging task to determine necessary agents...")
        val triagePrompt =
            promptManager.getPrompt("orchestrator.triageTask", mapOf("task" to prompt))
        val triageJson = ai.executeFlashPrompt(triagePrompt)
        val triageResult = try {
            jsonParser.decodeFromString<TriageResult>(triageJson)
        } catch (e: Exception) {
            logger.error("Could not parse triage result, defaulting to full context.", e)
            TriageResult(needs_web_research = true, needs_project_context = true)
        }
        logger.info("  -> Triage result: Web research needed: ${triageResult.needs_web_research}, Project context needed: ${triageResult.needs_project_context}")


        val bestPractices = if (triageResult.needs_web_research) {
            researcher.findBestPracticesFor(prompt)
        } else {
            ""
        }

        val projectContext = if (triageResult.needs_project_context) {
            architect.getProjectContextFor(prompt, projectRoot)
        } else {
            ""
        }

        val allContext = context + listOf(bestPractices, projectContext).filter { it.isNotBlank() }
        val planJson = generatePlanWithAI(prompt, *allContext.toTypedArray())

        if (planJson.startsWith("Error:")) {
            logger.error("Failed to generate a plan for '$prompt'. AI Failure: $planJson. Halting task.")
            return null
        }

        val workflowPlan = jsonParser.decodeFromString<WorkflowPlan>(planJson)
        logger.info("AI Reasoning: ${workflowPlan.reasoning}")

        val workflow = convertPlanToWorkflow(workflowPlan)
        if (workflow.isEmpty() && !workflowPlan.reasoning.contains("No changes needed")) {
            logger.error("Generated an empty or invalid workflow. Halting task.")
            return null
        }

        if (workflow.size == 1 && workflow.first() is AbstractCommand.RequestClarification) {
            val clarificationCommand = workflow.first() as AbstractCommand.RequestClarification
            val result = adapter.execute(clarificationCommand)
            val userAnswer = result.data as? String ?: "No response."
            context.add("User Clarification: $userAnswer")
            return handleTask(prompt, projectRoot, context, attempt, branch, createBranch)
        }

        val objection = antagonist.reviewPlan(planJson)
        if (objection != null) {
            logger.info("--- INITIATING SELF-CORRECTION (Attempt ${attempt + 1}) ---")
            context.add("The previous plan was rejected by the Antagonist. Reason: $objection")
            context.add("Please generate a new, valid plan that addresses this specific objection.")
            return handleTask(prompt, projectRoot, context, attempt + 1, branch, createBranch)
        }

        val manager = Manager(adapter, logger)
        val status = manager.executeWorkflow(workflow, prompt)

        return when (status) {
            is WorkflowStatus.Success -> {
                adapter.execute(AbstractCommand.Commit("WIP: ${status.commitMessage}"))
                logJournal("TASK_SUCCESS", mapOf("branch" to branch))
                branch
            }
            is WorkflowStatus.TestsFailed -> {
                logger.info("--- INITIATING SELF-CORRECTION (Attempt ${attempt + 1}) ---")
                context.add("The previous attempt failed with this test error:\n${status.testOutput}")
                context.add("These steps were successful before the failure:\n${status.successfulSteps.joinToString("\n")}")
                handleTask(prompt, projectRoot, context, attempt + 1, branch, createBranch)
            }
            is WorkflowStatus.Failure -> {
                logJournal("TASK_FAILURE", mapOf("branch" to branch, "reason" to status.reason))
                null
            }
        }
    }

    private fun deconstructPromptIntoSubTasks(
        userPrompt: String,
        projectType: String,
        specFileContent: String?,
    ): String {
        val specContent = if (specFileContent != null) {
            "PROJECT SPECIFICATION:\n$specFileContent"
        } else {
            ""
        }
        val prompt = promptManager.getPrompt(
            "orchestrator.deconstructPrompt", mapOf(
                "userPrompt" to userPrompt,
                "projectType" to projectType,
                "specFileContent" to specContent
            )
        )
        return ai.executeStrategicPrompt(prompt)
    }

    private fun cleanup(integrationBranch: String?, featureBranches: List<String>, mainBranch: String) {
        logger.info("Cleaning up temporary branches...")
        adapter.execute(AbstractCommand.SwitchToBranch(mainBranch))
        featureBranches.forEach { adapter.execute(AbstractCommand.DeleteBranch(it)) }
        integrationBranch?.let { adapter.execute(AbstractCommand.DeleteBranch(it)) }
        adapter.execute(AbstractCommand.DeleteFile(SESSION_FILE))
        adapter.execute(AbstractCommand.DeleteFile(JOURNAL_FILE))
        logger.info("Cleanup complete.")
    }

    private fun logJournal(action: String, data: Map<String, Any>) {
        val dataJsonObject = JsonObject(data.mapValues { (_, value) ->
            when (value) {
                is String -> JsonPrimitive(value)
                is Number -> JsonPrimitive(value)
                is Boolean -> JsonPrimitive(value)
                else -> JsonPrimitive(value.toString()) // Fallback for other types
            }
        })
        val entry =
            "{\"timestamp\": ${java.lang.System.currentTimeMillis()}, \"action\": \"$action\", \"data\": ${
                jsonParser.encodeToString(
                    JsonObject.serializer(),
                    dataJsonObject
                )
            }}\n"
        adapter.execute(AbstractCommand.LogJournalEntry(entry))
    }

    private fun saveSessionState(state: SessionState) {
        val json = jsonParser.encodeToString(SessionState.serializer(), state)
        adapter.execute(AbstractCommand.WriteFile(SESSION_FILE, json))
    }

    private fun loadSessionState(): SessionState? {
        val result = adapter.execute(AbstractCommand.ReadFile(SESSION_FILE))
        return if (result.isSuccess && result.data is String && (result.data.isNotBlank())) {
            try {
                jsonParser.decodeFromString(SessionState.serializer(), result.data)
            } catch (e: Exception) {
                logger.error("Could not parse session file, starting new session.", e)
                null
            }
        } else null
    }

    private fun generatePlanWithAI(userPrompt: String, vararg context: String): String {
        logger.info("Orchestrator: Generating workflow plan with AI...")
        val systemPrompt = promptManager.getPrompt(
            "orchestrator.generatePlan",
            mapOf("context" to context.joinToString("\n---\n"), "userPrompt" to userPrompt)
        )
        return ai.executeStrategicPrompt(systemPrompt)
    }

    private fun convertPlanToWorkflow(plan: WorkflowPlan): List<AbstractCommand> {
        return plan.steps.mapNotNull { step ->
            when (step.command_type) {
                "WRITE_FILE" -> {
                    val path =
                        step.parameters["path"]?.jsonPrimitive?.content ?: return@mapNotNull null
                    val content =
                        step.parameters["content"]?.jsonPrimitive?.content ?: return@mapNotNull null
                    AbstractCommand.WriteFile(path, content)
                }

                "RUN_SHELL" -> {
                    val command =
                        step.parameters["command"]?.jsonArray?.mapNotNull { it.jsonPrimitive.content }
                            ?: return@mapNotNull null
                    val workDir = step.parameters["workingDir"]?.jsonPrimitive?.content ?: "."
                    AbstractCommand.RunShellCommand(command, workDir)
                }

                "RUN_TESTS" -> {
                    val module = step.parameters["module"]?.jsonPrimitive?.content
                    val testName = step.parameters["testName"]?.jsonPrimitive?.content
                    AbstractCommand.RunTests(module, testName)
                }

                "DISPLAY_MESSAGE" -> {
                    val message =
                        step.parameters["message"]?.jsonPrimitive?.content ?: return@mapNotNull null
                    AbstractCommand.DisplayMessage(message)
                }

                "STAGE_FILES" -> {
                    val paths =
                        step.parameters["paths"]?.jsonArray?.mapNotNull { it.jsonPrimitive.content }
                            ?: return@mapNotNull null
                    AbstractCommand.StageFiles(paths)
                }

                "REQUEST_CLARIFICATION" -> {
                    val question = step.parameters["question"]?.jsonPrimitive?.content
                        ?: return@mapNotNull null
                    AbstractCommand.RequestClarification(question)
                }
                "PAUSE_AND_EXIT" -> {
                    val message = step.parameters["checkInMessage"]?.jsonPrimitive?.content
                        ?: "Execution paused."
                    AbstractCommand.PauseAndExit(message)
                }
                else -> null
            }
        }
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\config\ConfigStorage.kt
====================================================================
package com.hereliesaz.geministrator.core.config

interface ConfigStorage {
    fun saveApiKey(apiKey: String)
    fun loadApiKey(): String?
    fun savePreCommitReview(enabled: Boolean)
    fun loadPreCommitReview(): Boolean
    fun saveModelName(type: String, name: String)
    fun loadModelName(type: String, default: String): String
    fun saveConcurrencyLimit(limit: Int)
    fun loadConcurrencyLimit(): Int
    fun saveTokenLimit(limit: Int)
    fun loadTokenLimit(): Int

    // New methods for search configuration
    fun saveSearchApiKey(apiKey: String)
    fun loadSearchApiKey(): String?
    fun saveSearchEngineId(id: String)
    fun loadSearchEngineId(): String?

    // New methods for auth
    fun saveAuthMethod(method: String)
    fun loadAuthMethod(): String
    fun saveFreeTierOnly(enabled: Boolean)
    fun loadFreeTierOnly(): Boolean
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\Antagonist.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager

class Antagonist(
    private val logger: ILogger,
    private val ai: GeminiService,
    private val promptManager: PromptManager,
) {
    fun reviewPlan(planJson: String): String? {
        logger.info("Antagonist: Reviewing the proposed workflow...")
        val prompt = promptManager.getPrompt("antagonist.reviewPlan", mapOf("planJson" to planJson))
        val review = ai.executeStrategicPrompt(prompt)
        if (review.startsWith("OBJECTION:")) {
            logger.info("Antagonist: $review")
            return review
        }
        logger.info("Antagonist: The plan seems reasonable. No objections.")
        return null
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\Architect.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager
import java.io.File

class Architect(
    private val logger: ILogger,
    private val ai: GeminiService,
    private val adapter: ExecutionAdapter,
    private val promptManager: PromptManager,
) {
    fun getProjectContextFor(task: String, projectRoot: String): String {
        logger.info("Architect: Performing deep context analysis for '$task'.")
        val fileTree = File(projectRoot).walk().maxDepth(5)
            .filter { it.isFile && !it.path.contains(".git") && !it.path.contains(".idea") }
            .joinToString("\n") { it.relativeTo(File(projectRoot)).path }
        val triagePrompt = promptManager.getPrompt(
            "architect.getProjectContext",
            mapOf("fileTree" to fileTree, "task" to task)
        )
        val relevantFilePaths = ai.executeFlashPrompt(triagePrompt).split(",").map { it.trim() }
        logger.info("  -> Architect identified relevant files: $relevantFilePaths")
        val contextBuilder = StringBuilder("RELEVANT FILE CONTEXT:\n")
        relevantFilePaths.forEach { path ->
            if (path.isNotBlank()) {
                val result = adapter.execute(AbstractCommand.ReadFile(path))
                if (result.isSuccess) {
                    contextBuilder.append("--- FILE: $path ---\n")
                    contextBuilder.append((result.data as? String) ?: "Could not read file.")
                    contextBuilder.append("\n\n")
                }
            }
        }
        return contextBuilder.toString()
    }

    fun reviewStagedChanges(changes: Map<String, String>): Boolean {
        logger.info("Architect: Reviewing ${changes.size} staged files for architectural compliance.")
        val prompt = promptManager.getPrompt(
            "architect.reviewStagedChanges",
            mapOf("changes" to changes.toString())
        )
        val decision = ai.executeStrategicPrompt(prompt)
        logger.info("Architect's Decision: $decision")
        return decision.startsWith("APPROVE")
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\Designer.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ILogger

class Designer(private val logger: ILogger, private val adapter: ExecutionAdapter) {
    fun createSpecification(feature: String): List<AbstractCommand> {
        logger.info("Designer: Creating feature specification for '$feature'.")
        val sanitizedFeature = feature.replace(" ", "_").replace(Regex("[^A-Za-z0-9_]"), "")
        return listOf(AbstractCommand.WriteFile(
            path = "docs/specs/$sanitizedFeature.md",
            content = "# Feature: $feature\n\nThis feature should allow users to..."
        ))
    }
    fun updateChangelog(commitMessage: String) {
        logger.info("Designer: Updating changelog.")
        adapter.execute(AbstractCommand.AppendToFile("CHANGELOG.md", "\n- $commitMessage"))
    }
    fun recordHistoricalLesson(lesson: String) {
        logger.info("Designer: Recording important lesson in project history.")
        adapter.execute(AbstractCommand.AppendToFile("docs/history.md", "\n- $lesson"))
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\Researcher.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager

class Researcher(
    private val logger: ILogger,
    private val ai: GeminiService,
    private val adapter: ExecutionAdapter,
    private val promptManager: PromptManager,
) {
    fun findBestPracticesFor(topic: String): String {
        logger.info("Researcher: Searching for best practices regarding '$topic'.")
        val searchResult = adapter.execute(AbstractCommand.PerformWebSearch(topic))
        val prompt = promptManager.getPrompt(
            "researcher.findBestPractices",
            mapOf("searchResults" to searchResult.output, "topic" to topic)
        )
        return ai.executeFlashPrompt(prompt)
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\council\TechSupport.kt
====================================================================
package com.hereliesaz.geministrator.core.council

import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager

class TechSupport(
    private val logger: ILogger,
    private val ai: GeminiService,
    private val promptManager: PromptManager,
) {
    fun analyzeMergeConflict(conflictOutput: String): String {
        logger.info("Tech Support: Analyzing merge conflict...")
        val prompt = promptManager.getPrompt(
            "techSupport.analyzeMergeConflict",
            mapOf("conflictOutput" to conflictOutput)
        )
        return ai.executeStrategicPrompt(prompt)
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\core\tokenizer\Tokenizer.kt
====================================================================
package com.hereliesaz.geministrator.core.tokenizer

object Tokenizer {
    /**
     * A simple heuristic to approximate token count.
     * The official Gemini tokenizer is more complex, but a common rule of thumb
     * is that one token is approximately 4 characters for English text.
     */
    fun countTokens(text: String): Int {
        return (text.length / 4.0).toInt()
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\GeminiService.kt
====================================================================
package com.hereliesaz.geministrator.common

import com.hereliesaz.geministrator.core.config.ConfigStorage
import com.hereliesaz.geministrator.core.tokenizer.Tokenizer
import kotlinx.serialization.Serializable
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.json.Json
import java.net.HttpURLConnection
import java.net.URI

// Request/Response structures for serialization
@Serializable private data class GeminiRequest(val model: String, val contents: List<Content>)
@Serializable private data class GeminiResponse(val candidates: List<Candidate>)
@Serializable data class Candidate(val content: Content)
@Serializable data class Content(val parts: List<Part>, val role: String? = null)
@Serializable data class Part(val text: String)


class GeminiService(
    private val authMethod: String,
    private var apiKey: String,
    private val logger: ILogger,
    private val config: ConfigStorage,
    private val strategicModelName: String,
    private val flashModelName: String,
    private val promptManager: PromptManager? = null,
    private val adapter: ExecutionAdapter? = null, // Adapter for running gcloud
) {
    private val jsonParser = Json { isLenient = true; ignoreUnknownKeys = true }
    private val conversationHistory = mutableListOf<Content>()
    private var authToken: String? = null

    init {
        if (authMethod == "adc") {
            tryToGetAdcToken()
        }
    }

    private fun tryToGetAdcToken() {
        val result = adapter?.execute(
            AbstractCommand.RunShellCommand(
                listOf(
                    "gcloud",
                    "auth",
                    "application-default",
                    "print-access-token"
                )
            ), silent = true
        )
        if (result != null && result.isSuccess && result.output.isNotBlank()) {
            authToken = result.output.trim()
        }
    }

    fun isAdcAuthReady(): Boolean = authToken != null


    fun executeStrategicPrompt(prompt: String): String = executePrompt(prompt, strategicModelName)
    fun executeFlashPrompt(prompt: String): String = executePrompt(prompt, flashModelName)

    private fun executePrompt(prompt: String, model: String): String {
        if (authMethod == "apikey" && apiKey.isBlank()) {
            logger.error("Authentication failed. No API key is configured for 'apikey' method.")
            return "Error: Authentication failed."
        }
        if (authMethod == "adc" && authToken == null) {
            logger.error("Authentication failed. Could not obtain ADC token.")
            return "Error: Authentication failed."
        }

        conversationHistory.add(Content(parts = listOf(Part(prompt)), role = "user"))

        val tokenLimit = config.loadTokenLimit()
        val currentTokens = Tokenizer.countTokens(jsonParser.encodeToString(ListSerializer(Content.serializer()), conversationHistory))

        if (currentTokens > tokenLimit) {
            logger.info("WARNING: Token limit reached ($currentTokens / $tokenLimit). Performing graceful session restart.")
            val historyText = conversationHistory.joinToString("\n") { c -> "${c.role}: ${c.parts.first().text}" }
            val summaryPrompt = promptManager!!.getPrompt(
                "geminiService.summarizeSession",
                mapOf("historyText" to historyText)
            )
            val summary = internalExecute(summaryPrompt, model)
            logger.info("  -> Session summary created.")
            conversationHistory.clear()
            conversationHistory.add(Content(parts = listOf(Part("This is a new session. Here is the summary of the previous one to provide context:\n$summary")), role = "user"))
            conversationHistory.add(Content(parts = listOf(Part(prompt)), role = "user"))
        }

        val responseText = internalExecute(prompt, model, conversationHistory)
        conversationHistory.add(Content(parts = listOf(Part(responseText)), role = "model"))
        return responseText
    }

    private fun internalExecute(prompt: String, model: String, history: List<Content>? = null): String {
        logger.info("  -> Calling AI Model ($model) using auth method: $authMethod...")

        val baseUrl =
            "https://generativelanguage.googleapis.com/v1beta/models/$model:generateContent"

        val url = if (authMethod == "apikey") {
            URI("$baseUrl?key=$apiKey").toURL()
        } else {
            URI(baseUrl).toURL()
        }

        val connection = url.openConnection() as HttpURLConnection
        connection.requestMethod = "POST"
        connection.setRequestProperty("Content-Type", "application/json")
        connection.doOutput = true

        if (authMethod == "adc" && authToken != null) {
            connection.setRequestProperty("Authorization", "Bearer $authToken")
        }

        val request = GeminiRequest(model, history ?: listOf(Content(parts=listOf(Part(prompt)))))
        val requestBody = jsonParser.encodeToString(GeminiRequest.serializer(), request)

        connection.outputStream.use { it.write(requestBody.toByteArray(Charsets.UTF_8)) }

        return if (connection.responseCode == HttpURLConnection.HTTP_OK) {
            val responseText = connection.inputStream.bufferedReader().readText()
            try {
                jsonParser.decodeFromString<GeminiResponse>(responseText).candidates.first().content.parts.first().text
            } catch (e: Exception) {
                logger.error("Error parsing Gemini response: $responseText", e)
                "Error: Could not parse AI response."
            }
        } else {
            val error = connection.errorStream.bufferedReader().readText()
            logger.error("API call failed: $error")
            "Error: API call failed with status ${connection.responseCode}. Details: $error"
        }
    }

    fun clearSession() { conversationHistory.clear() }

    suspend fun validateApiKey(keyToValidate: String): Boolean {
        logger.info("  -> Validating API Key...")
        val url =
            URI("https://generativelanguage.googleapis.com/v1beta/models?key=$keyToValidate").toURL()
        return try {
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            val isValid = connection.responseCode == HttpURLConnection.HTTP_OK
            logger.info(if (isValid) "  -> API Key is valid." else "  -> API Key is invalid.")
            isValid
        } catch (e: Exception) {
            logger.error("  -> API Key validation failed with an exception", e)
            false
        }
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\AbstractCommand.kt
====================================================================
package com.hereliesaz.geministrator.common

/**
 * The complete, final set of universal commands for the agent system.
 */
sealed interface AbstractCommand {
    // File System
    data class WriteFile(val path: String, val content: String) : AbstractCommand
    data class ReadFile(val path: String) : AbstractCommand
    data class AppendToFile(val path: String, val content: String) : AbstractCommand
    data class DeleteFile(val path: String) : AbstractCommand
    data class LogJournalEntry(val entry: String) : AbstractCommand

    // Execution
    data class RunShellCommand(val command: List<String>, val workingDir: String = ".") :
        AbstractCommand
    data class RunTests(val module: String?, val testName: String?) : AbstractCommand

    // Version Control
    object GetCurrentBranch : AbstractCommand
    data class CreateAndSwitchToBranch(val branchName: String) : AbstractCommand
    data class SwitchToBranch(val branchName: String) : AbstractCommand
    data class MergeBranch(val branchName: String) : AbstractCommand
    data class DeleteBranch(val branchName: String) : AbstractCommand
    data class StageFiles(val filePaths: List<String>) : AbstractCommand
    data class Commit(val message: String) : AbstractCommand
    object DiscardAllChanges : AbstractCommand

    // UI & User Interaction
    data class DisplayMessage(val message: String) : AbstractCommand
    data class RequestUserDecision(val prompt: String, val options: List<String>) : AbstractCommand
    data class RequestCommitReview(val proposedCommitMessage: String) : AbstractCommand
    data class RequestClarification(val question: String) : AbstractCommand

    // External Tools
    data class PerformWebSearch(val query: String) : AbstractCommand

    // Orchestration Control
    data class PauseAndExit(val checkInMessage: String) : AbstractCommand
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\ExecutionAdapter.kt
====================================================================
package com.hereliesaz.geministrator.common

interface ExecutionAdapter {
    fun execute(command: AbstractCommand, silent: Boolean = false): ExecutionResult
}

data class ExecutionResult(
    val isSuccess: Boolean,
    val output: String,
    val data: Any? = null
)


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\ILogger.kt
====================================================================
package com.hereliesaz.geministrator.common

interface ILogger {
    fun info(message: String)
    fun error(message: String, e: Throwable? = null)
    fun interactive(message: String)
    fun prompt(message: String): String?
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\MultiStreamLogger.kt
====================================================================
package com.hereliesaz.geministrator.common

import java.io.File
import java.io.FileWriter
import java.io.PrintWriter
import java.text.SimpleDateFormat
import java.util.Date

class MultiStreamLogger(configDir: File) : ILogger {
    private val logFile: File

    init {
        configDir.mkdirs()
        logFile = File(configDir, "geministrator.log")
    }

    private fun writeToFile(level: String, message: String, e: Throwable? = null) {
        val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(Date())
        PrintWriter(FileWriter(logFile, true)).use { writer ->
            writer.println("[$timestamp] [$level] $message")
            e?.let { ex -> ex.printStackTrace(writer) }
        }
    }

    override fun info(message: String) {
        writeToFile("INFO", message)
    }

    override fun error(message: String, e: Throwable?) {
        val fullMessage = if (e != null) "$message: ${e.message}" else message
        System.err.println("[ERROR] $fullMessage")
        writeToFile("ERROR", message, e)
    }

    override fun interactive(message: String) {
        println(message)
        writeToFile("INTERACTIVE", message)
    }

    override fun prompt(message: String): String? {
        print(message)
        writeToFile("PROMPT", message)
        val response = readlnOrNull()
        writeToFile("RESPONSE", response ?: "<empty>")
        return response
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\common\PromptManager.kt
====================================================================
package com.hereliesaz.geministrator.common

import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonObject
import java.io.File

class PromptManager(private val configDir: File) {

    private val prompts: Map<String, String>

    init {
        val customPromptsFile = File(configDir, "prompts.json")
        prompts = if (customPromptsFile.exists()) {
            loadPromptsFromFile(customPromptsFile)
        } else {
            loadDefaultPrompts()
        }
    }

    private fun loadPromptsFromFile(file: File): Map<String, String> {
        return try {
            val json = Json.parseToJsonElement(file.readText()).jsonObject
            json.mapValues { it.value.toString().trim('"') }
        } catch (e: Exception) {
            println("[WARNING] Could not parse custom prompts.json. Falling back to defaults. Error: ${e.message}")
            loadDefaultPrompts()
        }
    }

    private fun loadDefaultPrompts(): Map<String, String> {
        val resourceStream = this::class.java.getResourceAsStream("/prompts.json")
            ?: throw IllegalStateException("Default prompts.json not found in resources.")
        val json = Json.parseToJsonElement(resourceStream.bufferedReader().readText()).jsonObject
        return json.mapValues { it.value.toString().trim('"') }
    }

    fun getPrompt(key: String, replacements: Map<String, String> = emptyMap()): String {
        var prompt = prompts[key] ?: throw IllegalArgumentException("Prompt key '$key' not found.")
        replacements.forEach { (placeholder, value) ->
            prompt = prompt.replace("{{${placeholder}}}", value)
        }
        return prompt
    }

    fun resetToDefaults(): Boolean {
        val customPromptsFile = File(configDir, "prompts.json")
        return if (customPromptsFile.exists()) {
            customPromptsFile.delete()
        } else {
            true // Already using defaults
        }
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\adapter\CliAdapter.kt
====================================================================
package com.hereliesaz.geministrator.adapter

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ExecutionResult
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.core.config.ConfigStorage
import kotlinx.serialization.json.Json
import java.io.File
import java.io.IOException
import java.net.HttpURLConnection
import java.net.URI
import java.net.URLEncoder
import java.util.concurrent.TimeUnit
import kotlin.system.exitProcess

class CliAdapter(
    private val config: ConfigStorage,
    private val logger: ILogger,
) : ExecutionAdapter {
    private val jsonParser = Json { isLenient = true; ignoreUnknownKeys = true }

    override fun execute(command: AbstractCommand, silent: Boolean): ExecutionResult {
        return when (command) {
            is AbstractCommand.AppendToFile -> try {
                File(command.path).appendText(command.content); ExecutionResult(
                    true,
                    "Appended to ${command.path}"
                )
            } catch (e: IOException) {
                ExecutionResult(false, e.message ?: "Failed to append")
            }

            is AbstractCommand.CreateAndSwitchToBranch -> runCommand(
                listOf(
                    "git",
                    "checkout",
                    "-b",
                    command.branchName
                ), silent = silent
            )

            is AbstractCommand.DeleteBranch -> runCommand(
                listOf(
                    "git",
                    "branch",
                    "-D",
                    command.branchName
                ), silent = silent
            )

            is AbstractCommand.DeleteFile -> try {
                File(command.path).delete(); ExecutionResult(true, "Deleted ${command.path}")
            } catch (e: SecurityException) {
                ExecutionResult(false, "Failed to delete file: ${e.message}")
            }
            is AbstractCommand.DiscardAllChanges -> {
                val resetResult =
                    runCommand(listOf("git", "reset", "--hard", "HEAD"), silent = silent)
                if (!resetResult.isSuccess) return resetResult
                runCommand(listOf("git", "clean", "-fd"), silent = silent)
            }

            is AbstractCommand.GetCurrentBranch -> runCommand(
                listOf(
                    "git",
                    "rev-parse",
                    "--abbrev-ref",
                    "HEAD"
                ), silent = silent
            )
            is AbstractCommand.LogJournalEntry -> try {
                val file = File(".orchestrator/journal.log")
                file.parentFile.mkdirs()
                file.appendText(command.entry)
                ExecutionResult(true, "Logged journal entry")
            } catch (e: IOException) {
                ExecutionResult(false, e.message ?: "Failed to log journal entry")
            }

            is AbstractCommand.MergeBranch -> runCommand(
                listOf("git", "merge", command.branchName),
                silent = silent
            )
            is AbstractCommand.PerformWebSearch -> performWebSearch(command.query)
            is AbstractCommand.ReadFile -> try {
                ExecutionResult(true, "Read file successfully.", File(command.path).readText())
            } catch (e: IOException) {
                ExecutionResult(false, "Failed to read file: ${e.message}")
            }

            is AbstractCommand.RequestClarification -> {
                logger.interactive("\n--- CLARIFICATION REQUIRED ---\n${command.question}")
                val response = logger.prompt("Your response: ") ?: ""
                ExecutionResult(true, "User provided clarification.", response)
            }
            is AbstractCommand.RequestCommitReview -> {
                logger.interactive("\n--- PENDING COMMIT: FINAL REVIEW ---\nProposed Commit Message: \"${command.proposedCommitMessage}\"\n--- STAGED CHANGES ---")
                val diffResult = runCommand(listOf("git", "diff", "--staged"))
                logger.interactive(diffResult.output)
                val response = logger.prompt("Approve and commit these changes? (y/n): ")
                val choice = if (response?.lowercase() == "y") "APPROVE" else "REJECT"
                ExecutionResult(true, "User chose '$choice'", choice)
            }

            is AbstractCommand.RequestUserDecision -> {
                logger.interactive("\n--- USER DECISION REQUIRED ---\n${command.prompt}")
                command.options.forEachIndexed { index, option -> logger.interactive("  ${index + 1}. $option") }
                val choiceStr = logger.prompt("Enter your choice (number): ")
                val choice = choiceStr?.toIntOrNull()
                val selection = choice?.let { command.options.getOrNull(it - 1) } ?: "Cancel"
                ExecutionResult(true, "User chose '$selection'", selection)
            }

            is AbstractCommand.RunShellCommand -> runCommand(
                command.command,
                command.workingDir,
                silent
            )
            is AbstractCommand.RunTests -> {
                val cmd = mutableListOf("./gradlew")
                val task = if (command.module != null) ":${command.module}:test" else "test"
                cmd.add(task)
                command.testName?.let {
                    cmd.add("--tests")
                    cmd.add(it)
                }
                cmd.add("--info")
                runCommand(cmd, ".", silent)
            }

            is AbstractCommand.StageFiles -> runCommand(
                listOf("git", "add") + command.filePaths,
                silent = silent
            )

            is AbstractCommand.SwitchToBranch -> runCommand(
                listOf(
                    "git",
                    "checkout",
                    command.branchName
                ), silent = silent
            )

            is AbstractCommand.WriteFile -> try {
                val file =
                    File(command.path); file.parentFile.mkdirs(); file.writeText(command.content); ExecutionResult(
                    true,
                    "Wrote to ${command.path}"
                )
            } catch (e: IOException) {
                ExecutionResult(false, e.message ?: "Failed to write file")
            }

            is AbstractCommand.Commit -> runCommand(
                listOf("git", "commit", "-m", command.message),
                silent = silent
            )

            is AbstractCommand.DisplayMessage -> {
                logger.interactive("[INFO] ${command.message}"); ExecutionResult(
                    true,
                    "Message displayed"
                )
            }

            is AbstractCommand.PauseAndExit -> {
                logger.interactive("\n--- EXECUTION PAUSED BY AI ---")
                logger.interactive(command.checkInMessage)
                logger.interactive("To resume, run Geministrator again. State has been saved.")
                exitProcess(0)
            }
        }
    }

    private fun runCommand(
        command: List<String>,
        workDir: String = ".",
        silent: Boolean = false,
    ): ExecutionResult {
        if (!silent) {
            logger.info("  [CLI Adapter] Executing: '${command.joinToString(" ")}'")
        }
        return try {
            val process =
                ProcessBuilder(command).directory(File(workDir)).redirectErrorStream(true).start()
            val output = process.inputStream.bufferedReader().readText()
            process.waitFor(120, TimeUnit.SECONDS)
            if (process.exitValue() == 0) ExecutionResult(true, output.ifBlank { "Command executed successfully." }, output)
            else ExecutionResult(false, "Exit code ${process.exitValue()}: $output", output)
        } catch (e: IOException) {
            ExecutionResult(false, e.message ?: "Failed to run shell command")
        } catch (e: InterruptedException) {
            ExecutionResult(false, "Command timed out: ${e.message}")
        }
    }

    private fun performWebSearch(query: String): ExecutionResult {
        val apiKey = config.loadSearchApiKey()
        val engineId = config.loadSearchEngineId()

        if (apiKey.isNullOrBlank() || engineId.isNullOrBlank()) {
            return ExecutionResult(
                false,
                "Web search is not configured. Please use 'geministrator config --search-api-key YOUR_KEY --search-engine-id YOUR_ID' to set it up."
            )
        }

        logger.info("  [CLI Adapter] Performing web search for: '$query'")

        try {
            val encodedQuery = URLEncoder.encode(query, "UTF-8")
            val url =
                URI("https://www.googleapis.com/customsearch/v1?key=$apiKey&cx=$engineId&q=$encodedQuery").toURL()
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            connection.setRequestProperty("Accept", "application/json")

            return if (connection.responseCode == HttpURLConnection.HTTP_OK) {
                val responseText = connection.inputStream.bufferedReader().readText()
                val searchResponse = jsonParser.decodeFromString<SearchResponse>(responseText)
                val summary = searchResponse.items.joinToString("\n---\n") {
                    "Title: ${it.title}\nSnippet: ${it.snippet}\nURL: ${it.link}"
                }.ifBlank { "No relevant search results found." }
                ExecutionResult(true, summary)
            } else {
                val error = connection.errorStream.bufferedReader().readText()
                ExecutionResult(
                    false,
                    "Web search failed with status ${connection.responseCode}: $error"
                )
            }
        } catch (e: Exception) {
            return ExecutionResult(false, "An exception occurred during web search: ${e.message}")
        }
    }
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\adapter\CliConfigStorage.kt
====================================================================
package com.hereliesaz.geministrator.adapter

import com.hereliesaz.geministrator.core.config.ConfigStorage
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.util.Properties

class CliConfigStorage(
    private val configDir: File = File(System.getProperty("user.home"), ".gemini-orchestrator")
) : ConfigStorage {
    private val configFile = File(configDir, "config.properties")
    private val properties = Properties()
    private val KEY_API = "GEMINI_API_KEY"
    private val KEY_REVIEW = "PRE_COMMIT_REVIEW"
    private val KEY_CONCURRENCY = "CONCURRENCY_LIMIT"
    private val KEY_TOKEN_LIMIT = "TOKEN_LIMIT"
    private val KEY_MODEL_STRATEGIC = "MODEL_STRATEGIC"
    private val KEY_MODEL_FLASH = "MODEL_FLASH"
    private val KEY_SEARCH_API = "SEARCH_API_KEY"
    private val KEY_SEARCH_ENGINE_ID = "SEARCH_ENGINE_ID"
    private val KEY_AUTH_METHOD = "AUTH_METHOD"
    private val KEY_FREE_TIER_ONLY = "FREE_TIER_ONLY"


    init {
        configDir.mkdirs()
        if (configFile.exists()) { FileInputStream(configFile).use { properties.load(it) } }
    }

    fun getConfigDirectory(): File = configDir

    private fun saveProperties() { FileOutputStream(configFile).use { properties.store(it, "Gemini Orchestrator Configuration") } }
    override fun saveApiKey(apiKey: String) { properties.setProperty(KEY_API, apiKey); saveProperties() }
    override fun loadApiKey(): String? = properties.getProperty(KEY_API)
    override fun savePreCommitReview(enabled: Boolean) { properties.setProperty(KEY_REVIEW, enabled.toString()); saveProperties() }
    override fun loadPreCommitReview(): Boolean = properties.getProperty(KEY_REVIEW, "true").toBoolean()
    override fun saveConcurrencyLimit(limit: Int) { properties.setProperty(KEY_CONCURRENCY, limit.toString()); saveProperties() }
    override fun loadConcurrencyLimit(): Int = properties.getProperty(KEY_CONCURRENCY, "2").toIntOrNull() ?: 2
    override fun saveTokenLimit(limit: Int) { properties.setProperty(KEY_TOKEN_LIMIT, limit.toString()); saveProperties() }
    override fun loadTokenLimit(): Int = properties.getProperty(KEY_TOKEN_LIMIT, "500000").toIntOrNull() ?: 500000
    override fun saveModelName(type: String, name: String) { properties.setProperty(if (type == "strategic") KEY_MODEL_STRATEGIC else KEY_MODEL_FLASH, name); saveProperties() }
    override fun loadModelName(type: String, default: String): String = properties.getProperty(if (type == "strategic") KEY_MODEL_STRATEGIC else KEY_MODEL_FLASH, default)

    override fun saveSearchApiKey(apiKey: String) {
        properties.setProperty(KEY_SEARCH_API, apiKey); saveProperties()
    }

    override fun loadSearchApiKey(): String? = properties.getProperty(KEY_SEARCH_API)
    override fun saveSearchEngineId(id: String) {
        properties.setProperty(KEY_SEARCH_ENGINE_ID, id); saveProperties()
    }

    override fun loadSearchEngineId(): String? = properties.getProperty(KEY_SEARCH_ENGINE_ID)

    override fun saveAuthMethod(method: String) {
        properties.setProperty(KEY_AUTH_METHOD, method); saveProperties()
    }

    override fun loadAuthMethod(): String =
        properties.getProperty(KEY_AUTH_METHOD, "adc") // Default to adc

    override fun saveFreeTierOnly(enabled: Boolean) {
        properties.setProperty(KEY_FREE_TIER_ONLY, enabled.toString()); saveProperties()
    }

    override fun loadFreeTierOnly(): Boolean =
        properties.getProperty(KEY_FREE_TIER_ONLY, "false").toBoolean()
}


====================================================================
FILE: .\cli\src\main\kotlin\com\hereliesaz\geministrator\adapter\SearchModels.kt
====================================================================
package com.hereliesaz.geministrator.adapter

import kotlinx.serialization.Serializable

@Serializable
data class SearchResponse(
    val items: List<SearchItem> = emptyList(),
)

@Serializable
data class SearchItem(
    val title: String? = null,
    val link: String? = null,
    val snippet: String? = null,
)


====================================================================
FILE: .\cli\src\main\res\prompts.json
====================================================================
{
    "antagonist.reviewPlan": "You are The Antagonist, a cynical but brilliant principal engineer. Your only goal is to find flaws in proposed plans.\nCritique the following workflow plan. Look for missing steps (especially testing), inefficiencies, or potential risks.\nIf you find a critical flaw, respond with \"OBJECTION: [Your reason]\".\nIf the plan is sound, respond with \"APPROVE\".\n\nPROPOSED PLAN (in JSON):\n{{planJson}}",
    "architect.getProjectContext": "You are an expert software architect. Your job is to identify the most relevant files for a given task. From the following file tree, list the 3-5 most critical files needed to accomplish the task. Respond with ONLY a comma-separated list of file paths.\n\nFILE TREE:\n{{fileTree}}\n\nTASK: \"{{task}}\"",
    "architect.reviewStagedChanges": "You are The Architect, an expert on software architecture. The following code changes have been proposed. Review them for any potential violations of clean architecture principles, unintended side effects, or major flaws. Respond with \"APPROVE\" if the changes are acceptable, or \"REJECT: [reason]\" if they are not.\n\nPROPOSED CHANGES:\n{{changes}}\n\nYour decision:",
    "orchestrator.deconstructPrompt": "You are an expert project manager. Deconstruct the following high-level user request into a series of smaller, parallelizable sub-tasks. You MUST identify dependencies between tasks.\n\nYour response MUST be ONLY a single, valid JSON object of the format:\n{ \"sub_tasks\": [ { \"description\": \"...\", \"responsible_component\": \"...\", \"depends_on\": [1, 2] } ] }\nThe `depends_on` field should contain a list of indices of tasks that must be completed before this one.\nTasks with no dependencies should have an empty `depends_on` list.\n\nPROJECT TYPE: {{projectType}}\n\nUSER REQUEST: \"{{userPrompt}}\"\n\n{{specFileContent}}",
    "orchestrator.generatePlan": "You are an expert software development orchestrator. You will be given a user's request and rich context, including the full content of relevant files.\nYour task is to create a precise, step-by-step workflow plan to accomplish the request.\nYour plan must be in a single, valid JSON object.\n\nIMPORTANT:\n- Your response MUST be only the JSON object, with no other text, comments, or markdown.\n- When modifying a file, your `WRITE_FILE` command must contain the *entire* new content of the file.\n- For `RUN_SHELL`, the `command` parameter MUST be a JSON array of strings (e.g., [\"./gradlew\", \"build\"]). Do not use shell operators like && or |; create separate steps.\n- For `STAGE_FILES`, the `paths` parameter MUST be a JSON array of file path strings.\n- If you modify code, you MUST include a `RUN_TESTS` step before the `STAGE_FILES` step.\n- If the provided context is insufficient, your ONLY step should be a `REQUEST_CLARIFICATION` command.\n- If no changes are needed, provide an empty `steps` array and explain why in the `reasoning`.\n- You can use the `PauseAndExit` command to strategically halt execution and schedule a check-in with the user.\n\nCONTEXT PROVIDED:\n{{context}}\n\nBased on the user's request and all the provided file content and context, create the JSON workflow plan.\n\nUser Request: \"{{userPrompt}}\"",
    "orchestrator.triageTask": "You are a fast and efficient task triage agent. Your sole purpose is to determine what resources are needed for a given software development task. Look at the task description and respond with ONLY a single, valid JSON object. Do not add any other text or markdown.\n\nThe JSON object should have two boolean keys:\n- `needs_web_research`: Set to true if the task requires searching for external libraries, APIs, documentation, or best practices.\n- `needs_project_context`: Set to true if the task requires understanding the existing project files, code structure, or architecture.\n\nTASK: \"{{task}}\"",
    "researcher.findBestPractices": "You are a Senior Staff Engineer. Based on the following web search results, summarize the current best practices for the topic.\n\nSEARCH RESULTS:\n{{searchResults}}\n\nTOPIC: \"{{topic}}\"",
    "techSupport.analyzeMergeConflict": "You are a Tech Support specialist for a team of AI agents. The following 'git merge' command failed. Analyze the conflict output and explain the root cause. Propose a clear, step-by-step strategy for how another AI agent could resolve this conflict.\n\nCONFLICT OUTPUT:\n{{conflictOutput}}\n\nYour analysis and resolution plan:",
    "geminiService.summarizeSession": "Summarize the key points and context of the following conversation to preserve memory for a new session:\n\n{{historyText}}"
}


====================================================================
FILE: .\app_android\build.gradle.kts
====================================================================
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
}

android {
    namespace = "com.hereliesaz.geministrator.android"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.hereliesaz.geministrator.android"
        minSdk = 26
        targetSdk = 34
        versionCode = 2
        versionName = "1.1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        // This version is aligned with the project's Kotlin version (1.9.23)
        kotlinCompilerExtensionVersion = "2.0.0"
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

dependencies {
    // Project Modules
    implementation(project(":cli"))

    // Core & UI
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime)
    implementation(libs.androidx.activity.compose)

    // Compose Bill of Materials
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.compose.ui)
    implementation(libs.androidx.compose.ui.graphics)
    implementation(libs.androidx.compose.ui.tooling.preview)
    implementation(libs.androidx.compose.foundation)

    // Material 3 and Adaptive Layouts
    implementation(libs.androidx.material3)
    implementation(libs.androidx.material3.window)
            implementation(libs.androidx.material3.adaptive)
            implementation(libs.androidx.material3.adaptive.navigation.suite)

            // Navigation
            implementation(libs.androidx.navigation.compose)

            // ViewModel
            implementation(libs.androidx.lifecycle.viewmodel.compose)

            // On-device Git
            implementation(libs.eclipse.jgit)

            // Testing
            testImplementation(libs.junit)
            androidTestImplementation(libs.androidx.test.ext.junit)
            androidTestImplementation(libs.androidx.test.espresso.core)
            androidTestImplementation(platform(libs.androidx.compose.bom))
            androidTestImplementation(libs.androidx.compose.ui.test.junit4)

            // Debugging
            debugImplementation(libs.androidx.compose.ui.tooling)
            debugImplementation(libs.androidx.compose.ui.test.manifest)
}


====================================================================
FILE: .\app_android\src\main\AndroidManifest.xml
====================================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="28" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Geministrator"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.Geministrator">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\MainActivity.kt
====================================================================
package com.hereliesaz.geministrator.android

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.activity.viewModels
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import com.hereliesaz.geministrator.android.ui.main.MainScreen
import com.hereliesaz.geministrator.android.ui.project.ProjectSetupScreen
import com.hereliesaz.geministrator.android.ui.project.ProjectViewModel
import com.hereliesaz.geministrator.android.ui.theme.GeministratorTheme

class MainActivity : ComponentActivity() {
    private val projectViewModel: ProjectViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            val projectState by projectViewModel.uiState.collectAsState()

            GeministratorTheme {
                if (projectState.projectUri == null) {
                    ProjectSetupScreen(projectViewModel)
                } else {
                    MainScreen(projectViewModel = projectViewModel)
                }
            }
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\theme\Color.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.theme

import androidx.compose.ui.graphics.Color

// Expressive Palette
val Primary = Color(0xFF6200EE)
val PrimaryVariant = Color(0xFF3700B3)
val Secondary = Color(0xFF03DAC6)
val SecondaryVariant = Color(0xFF018786)
val Background = Color(0xFF121212)
val Surface = Color(0xFF1E1E1E)
val Error = Color(0xFFCF6679)
val OnPrimary = Color.White
val OnSecondary = Color.Black
val OnBackground = Color.White
val OnSurface = Color.White
val OnError = Color.Black

// Agent Colors
val OrchestratorColor = Color(0xFFFFFFFF) // White
val ArchitectColor = Color(0xFF4FC3F7)    // Light Blue
val ResearcherColor = Color(0xFFFFF176)   // Pale Yellow
val DesignerColor = Color(0xFF81C784)     // Green
val AntagonistColor = Color(0xFFE57373)   // Red
val TechSupportColor = Color(0xFFFFB74D)  // Orange
val ManagerColor = Color(0xFF9575CD)      // Deep Purple


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\theme\Theme.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.theme

import android.app.Activity
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat

private val DarkColorScheme = darkColorScheme(
    primary = Primary,
    secondary = Secondary,
    background = Background,
    surface = Surface,
    onPrimary = OnPrimary,
    onSecondary = OnSecondary,
    onBackground = OnBackground,
    onSurface = OnSurface,
    error = Error,
    onError = OnError
)

private val LightColorScheme = lightColorScheme(
    primary = PrimaryVariant,
    secondary = SecondaryVariant,
    background = Color(0xFFFFFFFF),
    surface = Color(0xFFF5F5F5),
    onPrimary = OnPrimary,
    onSecondary = OnSecondary,
    onBackground = Color.Black,
    onSurface = Color.Black,
    error = Error,
    onError = OnError
)

@Composable
fun GeministratorTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }
    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.primary.toArgb()
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\theme\Type.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
)


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\theme\Agent.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.theme

import androidx.compose.ui.graphics.Color

enum class Agent(val color: Color) {
    ORCHESTRATOR(OrchestratorColor),
    ARCHITECT(ArchitectColor),
    RESEARCHER(ResearcherColor),
    DESIGNER(DesignerColor),
    ANTAGONIST(AntagonistColor),
    TECH_SUPPORT(TechSupportColor),
    MANAGER(ManagerColor)
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\main\MainScreen.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.main

import android.net.Uri
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Tab
import androidx.compose.material3.TabRow
import androidx.compose.material3.Text
import androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteScaffold
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.compose.rememberNavController
import com.hereliesaz.geministrator.android.ui.core.GeministratorNavHost
import com.hereliesaz.geministrator.android.ui.project.ProjectViewModel
import com.hereliesaz.geministrator.android.ui.session.SessionScreen

@Composable
fun MainScreen(projectViewModel: ProjectViewModel) {
    val navController = rememberNavController()
    val currentDestination = remember { mutableStateOf("sessions") }

    NavigationSuiteScaffold(
        navigationSuiteItems = {
            geministratorNavSuite(
                onNavigate = {
                    currentDestination.value = it
                    navController.navigate(it)
                },
                currentDestination = currentDestination.value
            )
        }
    ) {
        Scaffold { innerPadding ->
            GeministratorNavHost(
                navController = navController,
                projectViewModel = projectViewModel,
                modifier = Modifier.padding(innerPadding)
            )
        }
    }
}

@Composable
fun MainSessionView(mainViewModel: MainViewModel = viewModel(), projectViewModel: ProjectViewModel) {
    val uiState by mainViewModel.uiState.collectAsState()
    val sessions = uiState.sessions
    val selectedIndex = uiState.selectedSessionIndex

    if (uiState.showNewSessionDialog) {
        NewSessionDialog(
            onDismiss = { mainViewModel.onDismissNewSessionDialog() },
            onConfirm = { prompt -> mainViewModel.startSession(prompt, projectViewModel) }
        )
    }

    Column(modifier = Modifier.fillMaxSize()) {
        TabRow(selectedTabIndex = selectedIndex) {
            sessions.forEachIndexed { index, session ->
                Tab(
                    selected = selectedIndex == index,
                    onClick = { mainViewModel.selectSession(index) },
                    text = { Text(text = session.title) }
                )
            }
            IconButton(onClick = { mainViewModel.onShowNewSessionDialog() }) {
                Icon(imageVector = Icons.Default.Add, contentDescription = "New Session")
            }
        }
        if (sessions.isNotEmpty()) {
            val selectedSession = sessions[selectedIndex]
            Box(modifier = Modifier.weight(1f)) {
                SessionScreen(sessionViewModel = selectedSession.viewModel)
            }
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\main\MainViewModel.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.main

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import com.hereliesaz.geministrator.android.ui.project.ProjectViewModel
import com.hereliesaz.geministrator.android.ui.session.Session
import com.hereliesaz.geministrator.android.ui.session.SessionViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update

class MainViewModel(private val application: Application) : AndroidViewModel(application) {
    private val _uiState = MutableStateFlow(MainUiState())
    val uiState = _uiState.asStateFlow()

    fun startSession(prompt: String, projectViewModel: ProjectViewModel) {
        val projectCachePath = projectViewModel.uiState.value.localCachePath ?: return

        val sessionViewModel = SessionViewModel(application, prompt, projectViewModel)

        val nextId = (_uiState.value.sessions.maxOfOrNull { it.id } ?: 0) + 1
        val title = prompt.take(20).let { if (it.length == 20) "$it..." else it }
        val newSession = Session(
            id = nextId,
            title = title,
            initialPrompt = prompt,
            viewModel = sessionViewModel
        )
        _uiState.update {
            it.copy(
                sessions = it.sessions + newSession,
                selectedSessionIndex = it.sessions.size,
                showNewSessionDialog = false
            )
        }
    }

    fun onShowNewSessionDialog() {
        _uiState.update { it.copy(showNewSessionDialog = true) }
    }

    fun onDismissNewSessionDialog() {
        _uiState.update { it.copy(showNewSessionDialog = false) }
    }

    fun selectSession(index: Int) {
        if (index in _uiState.value.sessions.indices) {
            _uiState.update { it.copy(selectedSessionIndex = index) }
        }
    }
}

data class MainUiState(
    val sessions: List<Session> = emptyList(),
    val selectedSessionIndex: Int = 0,
    val showNewSessionDialog: Boolean = false
)


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\main\NavRail.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.main

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.History
import androidx.compose.material.icons.filled.Save
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.SmartToy
import androidx.compose.material3.Icon
import androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteScope
import androidx.compose.runtime.Composable

fun NavigationSuiteScope.geministratorNavSuite(
    onNavigate: (String) -> Unit,
    currentDestination: String
) {
    item(
        selected = currentDestination == "sessions",
        onClick = { onNavigate("sessions") },
        icon = { Icon(Icons.Default.SmartToy, contentDescription = "Sessions") }
    )
    item(
        selected = currentDestination == "save_file",
        onClick = { onNavigate("save_file") },
        icon = { Icon(Icons.Default.Save, contentDescription = "Save File") }
    )
    item(
        selected = currentDestination == "settings",
        onClick = { onNavigate("settings") },
        icon = { Icon(Icons.Default.Settings, contentDescription = "Settings") }
    )
    item(
        selected = currentDestination == "history",
        onClick = { onNavigate("history") },
        icon = { Icon(Icons.Default.History, contentDescription = "History") }
    )
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\main\NewSessionDialog.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.main

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun NewSessionDialog(
    onDismiss: () -> Unit,
    onConfirm: (String) -> Unit
) {
    var prompt by remember { mutableStateOf("") }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Start a New Session") },
        text = {
            Column {
                Text("Enter the high-level task for the orchestrator.")
                Spacer(modifier = Modifier.height(16.dp))
                OutlinedTextField(
                    value = prompt,
                    onValueChange = { prompt = it },
                    label = { Text("Task Prompt") },
                    singleLine = false
                )
            }
        },
        confirmButton = {
            TextButton(
                onClick = {
                    if (prompt.isNotBlank()) {
                        onConfirm(prompt)
                    }
                },
                enabled = prompt.isNotBlank()
            ) {
                Text("Start")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\core\GeministratorNavHost.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.core

import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import com.hereliesaz.geministrator.android.ui.file.FileSaveScreen
import com.hereliesaz.geministrator.android.ui.main.MainSessionView
import com.hereliesaz.geministrator.android.ui.main.MainViewModel
import com.hereliesaz.geministrator.android.ui.navigation.HistoryScreen
import com.hereliesaz.geministrator.android.ui.navigation.SettingsScreen
import com.hereliesaz.geministrator.android.ui.project.ProjectViewModel
import com.hereliesaz.geministrator.android.ui.settings.SettingsViewModel

@Composable
fun GeministratorNavHost(
    navController: NavHostController,
    projectViewModel: ProjectViewModel,
    modifier: Modifier = Modifier
) {
    val mainViewModel: MainViewModel = viewModel()
    val settingsViewModel: SettingsViewModel = viewModel()

    NavHost(
        navController = navController,
        startDestination = "sessions",
        modifier = modifier
    ) {
        composable("sessions") {
            MainSessionView(mainViewModel, projectViewModel)
        }
        composable("save_file") {
            FileSaveScreen()
        }
        composable("settings") {
            SettingsScreen(settingsViewModel)
        }
        composable("history") {
            HistoryScreen()
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\session\SessionScreen.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.session

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.hereliesaz.geministrator.android.ui.components.MarkdownText
import com.hereliesaz.geministrator.android.ui.components.ShimmerPlaceholder

@Composable
fun SessionScreen(sessionViewModel: SessionViewModel = viewModel()) {
    val logEntries by sessionViewModel.logEntries.collectAsState()
    val listState = rememberLazyListState()

    LaunchedEffect(logEntries.size) {
        if (logEntries.isNotEmpty()) {
            listState.animateScrollToItem(logEntries.size - 1)
        }
    }

    LazyColumn(
        state = listState,
        modifier = Modifier
            .fillMaxSize()
            .background(MaterialTheme.colorScheme.surface),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        items(logEntries) { entry ->
            LogEntryItem(entry)
        }
    }
}

@Composable
fun LogEntryItem(entry: LogEntry) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Row {
            Text(
                text = "${entry.agent.name}:",
                color = entry.agent.color,
                fontWeight = FontWeight.Bold,
            )
            Text(
                text = " ${entry.message}",
                color = MaterialTheme.colorScheme.onSurface,
            )
        }
        Spacer(modifier = Modifier.height(8.dp))

        if (entry.content != null) {
            MarkdownText(text = entry.content)
        }

        if (entry.isWorking) {
            ShimmerPlaceholder(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(60.dp)
            )
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\session\SessionViewModel.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.session

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.hereliesaz.geministrator.android.data.AndroidConfigStorage
import com.hereliesaz.geministrator.android.data.AndroidExecutionAdapter
import com.hereliesaz.geministrator.android.data.AndroidLogger
import com.hereliesaz.geministrator.android.ui.project.ProjectViewModel
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.PromptManager
import com.hereliesaz.geministrator.core.Orchestrator
import com.hereliesaz.geministrator.core.config.ConfigStorage
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.io.File

class SessionViewModel(
    application: Application,
    private val prompt: String,
    private val projectViewModel: ProjectViewModel
) : AndroidViewModel(application) {

    private val _logEntries = MutableStateFlow<List<LogEntry>>(emptyList())
    val logEntries = _logEntries.asStateFlow()

    init {
        startOrchestration()
    }

    private fun startOrchestration() {
        viewModelScope.launch(Dispatchers.IO) {
            val projectRootPath = projectViewModel.uiState.value.localCachePath?.absolutePath
            if (projectRootPath == null) {
                _logEntries.value += LogEntry("Error: Project cache path is not available.", com.hereliesaz.geministrator.android.ui.theme.Agent.ANTAGONIST)
                return@launch
            }

            // 1. Initialize Android-specific implementations
            val logger = AndroidLogger(_logEntries)
            val configStorage: ConfigStorage = AndroidConfigStorage(getApplication())
            val executionAdapter = AndroidExecutionAdapter(projectViewModel, logger)

            // Re-use CLI prompt logic, but point it to a writable cache directory
            val configDir = File(getApplication<Application>().cacheDir, "gemini_config")
            configDir.mkdirs()
            val promptManager = PromptManager(configDir)

            // 2. Configure Gemini Service
            val apiKey = configStorage.loadApiKey()
            if (apiKey.isNullOrBlank()) {
                logger.error("FATAL: Gemini API Key is not configured. Please set it in the Settings screen.")
                return@launch
            }

            val geminiService = GeminiService(
                authMethod = "apikey",
                apiKey = apiKey,
                logger = logger,
                config = configStorage,
                strategicModelName = "gemini-1.5-pro-latest",
                flashModelName = "gemini-1.5-flash-latest",
                promptManager = promptManager,
                adapter = null // ADC not used in this flow
            )

            // 3. Initialize and run the Orchestrator
            val orchestrator = Orchestrator(
                adapter = executionAdapter,
                logger = logger,
                config = configStorage,
                promptManager = promptManager,
                ai = geminiService
            )

            logger.info("Orchestrator initialized. Starting workflow for prompt: \"$prompt\"")

            orchestrator.run(
                prompt = prompt,
                projectRoot = projectRootPath,
                projectType = "Android Application",
                specFileContent = null
            )
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\session\Session.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.session

import android.net.Uri
import androidx.lifecycle.ViewModelProvider
import com.hereliesaz.geministrator.android.ui.project.ProjectViewModel

data class Session(
    val id: Int,
    val title: String,
    val initialPrompt: String,
    val projectUri: Uri,
    val viewModel: SessionViewModel
)


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\session\LogEntry.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.session

import com.hereliesaz.geministrator.android.ui.theme.Agent

data class LogEntry(
    val message: String,
    val agent: Agent,
    val content: String? = null, // For holding markdown or code
    val isWorking: Boolean = false, // To show a placeholder
    val isAwaitingInput: Boolean = false // To show a prompt for user
)


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\navigation\SettingsScreen.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.navigation

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.hereliesaz.geministrator.android.ui.settings.SettingsViewModel

@Composable
fun SettingsScreen(settingsViewModel: SettingsViewModel = viewModel()) {
    val uiState by settingsViewModel.uiState.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Settings")
        OutlinedTextField(
            value = uiState.apiKey,
            onValueChange = { settingsViewModel.onApiKeyChange(it) },
            label = { Text("Gemini API Key") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            visualTransformation = PasswordVisualTransformation()
        )
        Spacer(modifier = Modifier.weight(1f))
        Button(
            onClick = { settingsViewModel.saveSettings() },
            modifier = Modifier.fillMaxWidth(),
            enabled = uiState.apiKey.isNotBlank()
        ) {
            Text("Save Settings")
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\navigation\HistoryScreen.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.navigation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier

@Composable
fun HistoryScreen() {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text("History Screen Placeholder")
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\components\Placeholder.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.components

import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.composed
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun ShimmerPlaceholder(modifier: Modifier = Modifier) {
    Box(
        modifier = modifier.shimmerEffect()
    )
}

fun Modifier.shimmerEffect(): Modifier = composed {
    val transition = rememberInfiniteTransition(label = "ShimmerTransition")
    val translateAnim = transition.animateFloat(
        initialValue = 0f,
        targetValue = 1000f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 1200),
        ),
        label = "ShimmerAnimation"
    )
    val brush = Brush.linearGradient(
        colors = listOf(
            Color.DarkGray.copy(alpha = 0.6f),
            Color.Gray.copy(alpha = 0.2f),
            Color.DarkGray.copy(alpha = 0.6f),
        ),
        start = Offset.Zero,
        end = Offset(x = translateAnim.value, y = translateAnim.value)
    )
    background(brush)
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\components\CodeBlock.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.dp

@Composable
fun CodeBlock(code: String) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(8.dp))
            .padding(16.dp)
    ) {
        Text(
            text = code,
            fontFamily = FontFamily.Monospace,
            color = Color.White
        )
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\components\MarkdownText.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.components

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.dp
import java.util.regex.Pattern

@Composable
fun MarkdownText(text: String) {
    val codeBlockPattern = Pattern.compile("```(.*?)```", Pattern.DOTALL)
    val parts = remember(text) {
        val matcher = codeBlockPattern.matcher(text)
        val result = mutableListOf<Pair<String, Boolean>>()
        var lastEnd = 0
        while (matcher.find()) {
            if (matcher.start() > lastEnd) {
                result.add(Pair(text.substring(lastEnd, matcher.start()), false))
            }
            result.add(Pair(matcher.group(1) ?: "", true))
            lastEnd = matcher.end()
        }
        if (lastEnd < text.length) {
            result.add(Pair(text.substring(lastEnd), false))
        }
        result
    }

    Column {
        parts.forEach { (content, isCode) ->
            if (isCode) {
                CodeBlock(code = content.trim())
            } else {
                Text(
                    text = content.trim(),
                    color = MaterialTheme.colorScheme.onSurface,
                    fontFamily = FontFamily.Monospace
                )
            }
            Spacer(modifier = Modifier.height(8.dp))
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\project\ProjectViewModel.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.project

import android.app.Application
import android.content.Intent
import android.net.Uri
import androidx.activity.result.ActivityResultLauncher
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.hereliesaz.geministrator.android.data.GitManager
import com.hereliesaz.geministrator.android.data.ProjectManager
import com.hereliesaz.geministrator.android.data.SafProjectCopier
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File

class ProjectViewModel(application: Application) : AndroidViewModel(application) {
    private val projectManager = ProjectManager(application)
    var gitManager: GitManager? = null
        private set

    private val _uiState = MutableStateFlow(ProjectUiState())
    val uiState = _uiState.asStateFlow()

    init {
        viewModelScope.launch {
            projectManager.getProjectFolderUri()?.let { uri ->
                _uiState.update { it.copy(projectUri = uri, isLoading = true) }
                val localCopyPath = withContext(Dispatchers.IO) {
                    SafProjectCopier.copyProjectToCache(getApplication(), uri)
                }
                gitManager = GitManager(localCopyPath)
                _uiState.update { it.copy(projectUri = uri, localCachePath = localCopyPath, isLoading = false) }
            }
        }
    }

    fun selectProject(launcher: ActivityResultLauncher<Intent>) {
        projectManager.openProjectFolderPicker(launcher)
    }

    fun cloneProject(url: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val result = withContext(Dispatchers.IO) {
                GitManager.cloneRepository(url, getApplication())
            }
            result.onSuccess { localRepoPath ->
                gitManager = GitManager(localRepoPath)
                _uiState.update {
                    it.copy(
                        localCachePath = localRepoPath,
                        isLoading = false,
                        cloneUrl = url,
                        projectUri = null // Cloned projects don't have a SAF URI
                    )
                }
            }.onFailure {
                // TODO: Propagate error to the UI
                _uiState.update { it.copy(isLoading = false) }
            }
        }
    }

    fun onProjectSelected(uri: Uri?) {
        uri?.let {
            viewModelScope.launch {
                _uiState.update { state -> state.copy(projectUri = it, isLoading = true) }
                projectManager.onProjectFolderSelected(it)
                val localCopyPath = withContext(Dispatchers.IO) {
                    SafProjectCopier.copyProjectToCache(getApplication(), it)
                }
                gitManager = GitManager(localCopyPath)
                _uiState.update { state -> state.copy(projectUri = it, localCachePath = localCopyPath, isLoading = false, cloneUrl = null) }
            }
        }
    }

    fun writeFile(filePath: String, content: String) {
        // If it's a SAF-based project, write back to the original location.
        _uiState.value.projectUri?.let {
            projectManager.writeFile(it, filePath, content)
        }

        // Always update the file in the local cache for consistency.
        _uiState.value.localCachePath?.let { cachePath ->
            val fileInCache = File(cachePath, filePath)
            fileInCache.parentFile?.mkdirs()
            fileInCache.writeText(content)
        }
    }

    fun readFile(filePath: String): String? {
        // For reading, the local cache is the source of truth for the app's logic.
        return _uiState.value.localCachePath?.let { cachePath ->
            val fileInCache = File(cachePath, filePath)
            if (fileInCache.exists()) fileInCache.readText() else null
        }
    }
}

data class ProjectUiState(
    val projectUri: Uri? = null,
    val localCachePath: File? = null,
    val isLoading: Boolean = false,
    val cloneUrl: String? = null
)


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\project\ProjectSetupScreen.kt
====================================================================
package com.hereliesaz.geministrator.android.data

import org.eclipse.jgit.api.Git
import org.eclipse.jgit.lib.Repository
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import java.io.File

class GitManager(private val projectCacheDir: File) {

    private val repository: Repository by lazy {
        val gitDir = File(projectCacheDir, ".git")
        FileRepositoryBuilder()
            .setGitDir(gitDir)
            .readEnvironment() // scan environment GIT_* variables
            .findGitDir() // scan up the file system tree
            .build()
    }

    private val git: Git by lazy {
        Git(repository)
    }

    fun init(): Result<Unit> = runCatching {
        if (!repository.directory.exists()) {
            Git.init().setDirectory(projectCacheDir).call()
        }
    }

    fun stageFile(filePath: String): Result<Unit> = runCatching {
        git.add().addFilepattern(filePath).call()
    }

    fun commit(message: String): Result<String> = runCatching {
        val revCommit = git.commit().setMessage(message).call()
        revCommit.fullMessage
    }

    fun getStatus(): Result<String> = runCatching {
        val status = git.status().call()
        val statusStringBuilder = StringBuilder()
        [cite_start]status.added.forEach { statusStringBuilder.append("ADDED: $it\n") } [cite: 398]
        [cite_start]status.modified.forEach { statusStringBuilder.append("MODIFIED: $it\n") } [cite: 398]
        [cite_start]status.removed.forEach { statusStringBuilder.append("REMOVED: $it\n") } [cite: 398]
        [cite_start]status.untracked.forEach { statusStringBuilder.append("UNTRACKED: $it\n") } [cite: 398]
        statusStringBuilder.toString().ifEmpty { "No changes." [cite_start]} [cite: 399]
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\ui\settings\SettingsViewModel.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.settings

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.hereliesaz.geministrator.android.data.AndroidConfigStorage
import com.hereliesaz.geministrator.core.config.ConfigStorage
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

class SettingsViewModel(application: Application) : AndroidViewModel(application) {
    private val config: ConfigStorage = AndroidConfigStorage(application)

    private val _uiState = MutableStateFlow(SettingsUiState())
    val uiState = _uiState.asStateFlow()

    init {
        loadSettings()
    }

    private fun loadSettings() {
        viewModelScope.launch {
            val apiKey = config.loadApiKey() ?: ""
            _uiState.update { it.copy(apiKey = apiKey) }
        }
    }

    fun onApiKeyChange(newKey: String) {
        _uiState.update { it.copy(apiKey = newKey) }
    }

    fun saveSettings() {
        viewModelScope.launch {
            config.saveApiKey(_uiState.value.apiKey)
            // You could add a "Saved!" message to the UI state here
        }
    }
}

data class SettingsUiState(
    val apiKey: String = ""
)


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\data\FileManager.kt
====================================================================
package com.hereliesaz.geministrator.android.data

import android.content.Context
import android.content.Intent
import android.net.Uri
import androidx.activity.result.ActivityResultLauncher

class FileManager(private val context: Context) {

    /**
     * Launches the system file picker to let the user choose a location to save a file.
     */
    fun saveFile(launcher: ActivityResultLauncher<Intent>, fileName: String, content: String) {
        val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply {
            addCategory(Intent.CATEGORY_OPENABLE)
            type = "text/plain" // Or any other MIME type
            putExtra(Intent.EXTRA_TITLE, fileName)
        }
        // We'll pass the content through a temporary store or another mechanism
        // For now, the ViewModel will hold it.
        launcher.launch(intent)
    }

    /**
     * Writes the given content to the Uri provided by the file picker.
     */
    fun writeFileContent(uri: Uri, content: String) {
        try {
            context.contentResolver.openOutputStream(uri)?.use { outputStream ->
                outputStream.bufferedWriter().use {
                    it.write(content)
                }
            }
        } catch (e: Exception) {
            // Handle exceptions like IOException
            e.printStackTrace()
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\data\ProjectManager.kt
====================================================================
package com.hereliesaz.geministrator.android.data

import android.content.Context
import android.content.Intent
import android.net.Uri
import androidx.activity.result.ActivityResultLauncher
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import androidx.documentfile.provider.DocumentFile
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.map
import java.io.BufferedReader
import java.io.InputStreamReader

private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "settings")
private val PROJECT_URI_KEY = stringPreferencesKey("project_folder_uri")

class ProjectManager(private val context: Context) {

    /**
     * Launches the system's folder picker for the user to select a project directory.
     */
    fun openProjectFolderPicker(launcher: ActivityResultLauncher<Intent>) {
        val intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE)
        launcher.launch(intent)
    }

    /**
     * Saves the URI of the folder the user selected, granting persistent access.
     */
    suspend fun onProjectFolderSelected(uri: Uri) {
        context.contentResolver.takePersistableUriPermission(
            uri,
            Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION
        )
        context.dataStore.edit { settings ->
            settings[PROJECT_URI_KEY] = uri.toString()
        }
    }

    /**
     * Retrieves the saved project folder URI, if one exists.
     */
    suspend fun getProjectFolderUri(): Uri? {
        val uriString = context.dataStore.data.map { it[PROJECT_URI_KEY] }.firstOrNull()
        return uriString?.let { Uri.parse(it) }
    }

    fun writeFile(projectUri: Uri, filePath: String, content: String) {
        val parent = DocumentFile.fromTreeUri(context, projectUri)
        val file = parent?.findFile(filePath) ?: parent?.createFile("text/plain", filePath)
        file?.let {
            context.contentResolver.openOutputStream(it.uri)?.use { stream ->
                stream.bufferedWriter().use { writer -> writer.write(content) }
            }
        }
    }

    fun readFile(projectUri: Uri, filePath: String): String? {
        val parent = DocumentFile.fromTreeUri(context, projectUri)
        val file = parent?.findFile(filePath)
        return file?.let {
            context.contentResolver.openInputStream(it.uri)?.use { stream ->
                BufferedReader(InputStreamReader(stream)).use { reader ->
                    reader.readText()
                }
            }
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\data\GitManager.kt
====================================================================
package com.hereliesaz.geministrator.android.data

import android.content.Context
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.lib.Repository
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import java.io.File
import java.util.UUID

class GitManager(private val projectCacheDir: File) {

    private val repository: Repository by lazy {
        val gitDir = File(projectCacheDir, ".git")
        FileRepositoryBuilder()
            .setGitDir(gitDir)
            .readEnvironment() // scan environment GIT_* variables
            .findGitDir() // scan up the file system tree
            .build()
    }

    private val git: Git by lazy {
        Git(repository)
    }

    fun init(): Result<Unit> = runCatching {
        if (!repository.directory.exists()) {
            Git.init().setDirectory(projectCacheDir).call()
        }
    }

    fun stageFile(filePath: String): Result<Unit> = runCatching {
        git.add().addFilepattern(filePath).call()
    }

    fun commit(message: String): Result<String> = runCatching {
        val revCommit = git.commit().setMessage(message).call()
        revCommit.fullMessage
    }

    fun getStatus(): Result<String> = runCatching {
        val status = git.status().call()
        val statusStringBuilder = StringBuilder()
        status.added.forEach { statusStringBuilder.append("ADDED: $it\n") }
        status.modified.forEach { statusStringBuilder.append("MODIFIED: $it\n") }
        status.removed.forEach { statusStringBuilder.append("REMOVED: $it\n") }
        status.untracked.forEach { statusStringBuilder.append("UNTRACKED: $it\n") }
        statusStringBuilder.toString().ifEmpty { "No changes." }
    }

    companion object {
        fun cloneRepository(url: String, context: Context): Result<File> = runCatching {
            val repoName = url.substringAfterLast('/').substringBeforeLast('.')
            val destination = File(context.cacheDir, "cloned_repos/${repoName}_${UUID.randomUUID()}")
            destination.mkdirs()

            Git.cloneRepository()
                .setURI(url)
                .setDirectory(destination)
                .call()

            destination
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\data\FileSaveScreen.kt
====================================================================
package com.hereliesaz.geministrator.android.ui.file

import android.app.Activity
import android.content.Intent
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel

@Composable
fun FileSaveScreen(fileViewModel: FileViewModel = viewModel()) {
    val uiState by fileViewModel.uiState.collectAsState()

    val saveFileLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            fileViewModel.onFileSelected(result.data?.data)
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        OutlinedTextField(
            value = uiState.fileName,
            onValueChange = { fileViewModel.onFileNameChange(it) },
            label = { Text("File Name") },
            modifier = Modifier.fillMaxWidth()
        )
        Spacer(modifier = Modifier.height(16.dp))
        OutlinedTextField(
            value = uiState.contentToSave,
            onValueChange = { fileViewModel.onContentChange(it) },
            label = { Text("File Content") },
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(
            onClick = { fileViewModel.initiateSave(saveFileLauncher) },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Save File")
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\data\SafProjectCopier.kt
====================================================================
package com.hereliesaz.geministrator.android.data

import android.content.Context
import android.net.Uri
import androidx.documentfile.provider.DocumentFile
import java.io.File
import java.io.FileOutputStream

object SafProjectCopier {

    /**
     * Copies a directory from a SAF Uri to a local cache directory.
     * This is necessary for libraries like JGit that require direct File API access.
     */
    fun copyProjectToCache(context: Context, projectUri: Uri): File {
        val cacheDir = File(context.cacheDir, "project_copy_${System.currentTimeMillis()}")
        cacheDir.mkdirs()

        val rootDocument = DocumentFile.fromTreeUri(context, projectUri)
        rootDocument?.let { doc ->
            copyDirectory(context, doc, cacheDir)
        }
        return cacheDir
    }

    private fun copyDirectory(context: Context, sourceDir: DocumentFile, destinationDir: File) {
        if (!destinationDir.exists()) {
            destinationDir.mkdirs()
        }

        sourceDir.listFiles().forEach { sourceFile ->
            val destinationFile = File(destinationDir, sourceFile.name ?: "unknown_file")
            if (sourceFile.isDirectory) {
                copyDirectory(context, sourceFile, destinationFile)
            } else {
                copyFile(context, sourceFile, destinationFile)
            }
        }
    }

    private fun copyFile(context: Context, sourceFile: DocumentFile, destinationFile: File) {
        try {
            context.contentResolver.openInputStream(sourceFile.uri)?.use { inputStream ->
                FileOutputStream(destinationFile).use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
            }
        } catch (e: Exception) {
            // In a real implementation, propagate this error to the UI
            e.printStackTrace()
        }
    }

    /**
     * Syncs changes from the local cache back to the original SAF Uri.
     * (This is a simplified example; a real implementation needs robust diffing.)
     */
    fun syncCacheToSaf(context: Context, cacheDir: File, projectUri: Uri) {
        val projectRoot = DocumentFile.fromTreeUri(context, projectUri) ?: return
        val cacheFiles = cacheDir.walk().filter { it.isFile }.toList()

        cacheFiles.forEach { cacheFile ->
            val relativePath = cacheFile.relativeTo(cacheDir).path
            // This is a naive implementation. A real one would check for existing files
            // and handle updates and deletes.
            writeFileToSaf(context, projectRoot, relativePath, cacheFile.readText())
        }
    }

    private fun writeFileToSaf(context: Context, root: DocumentFile, path: String, content: String) {
        val parts = path.split(File.separator)
        var currentDir = root
        // Traverse or create directories
        parts.dropLast(1).forEach { dirName ->
            val nextDir = currentDir.findFile(dirName) ?: currentDir.createDirectory(dirName)
            currentDir = nextDir ?: return // Stop if directory creation fails
        }

        // Create or find the file
        val fileName = parts.last()
        val file = currentDir.findFile(fileName) ?: currentDir.createFile("text/plain", fileName)

        // Write content to the file
        file?.let {
            try {
                context.contentResolver.openOutputStream(it.uri)?.use { stream ->
                    stream.bufferedWriter().write(content)
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}


====================================================================
FILE: .\app_android\src\main\java\com\hereliesaz\geministrator\android\data\AndroidExecutionAdapter.kt
====================================================================
package com.hereliesaz.geministrator.android.data

import com.hereliesaz.geministrator.android.ui.project.ProjectViewModel
import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ExecutionResult
import com.hereliesaz.geministrator.common.ILogger
import java.io.File

class AndroidExecutionAdapter(
    private val projectViewModel: ProjectViewModel,
    private val logger: ILogger
) : ExecutionAdapter {

    private val gitManager: GitManager?
        get() = projectViewModel.gitManager

    private val projectCacheDir: File?
        get() = projectViewModel.uiState.value.localCachePath

    override fun execute(command: AbstractCommand, silent: Boolean): ExecutionResult {
        if (projectCacheDir == null && command !is AbstractCommand.LogJournalEntry) {
            return ExecutionResult(false, "Project cache directory is not initialized.")
        }

        return when (command) {
            is AbstractCommand.WriteFile -> {
                projectViewModel.writeFile(command.path, command.content)
                ExecutionResult(true, "Wrote to ${command.path}")
            }
            is AbstractCommand.ReadFile -> {
                val content = projectViewModel.readFile(command.path)
                if (content != null) {
                    ExecutionResult(true, "Read file successfully.", content)
                } else {
                    ExecutionResult(false, "Failed to read file: ${command.path}")
                }
            }
            is AbstractCommand.RunTests -> {
                // Testing is not implemented in the Android environment.
                logger.info("Skipping tests in Android environment.")
                ExecutionResult(true, "Tests skipped on Android.")
            }
            is AbstractCommand.GetCurrentBranch -> {
                ExecutionResult(true, "main") // Simplified for Android
            }
            is AbstractCommand.CreateAndSwitchToBranch -> {
                // JGit doesn't have a direct checkout -b equivalent.
                // It's a combination of branchCreate and checkout.
                // For now, we simulate this.
                ExecutionResult(true, "Simulated create and switch to ${command.branchName}")
            }
            is AbstractCommand.StageFiles -> {
                var success = true
                command.filePaths.forEach { path ->
                    gitManager?.stageFile(path)?.onFailure { success = false }
                }
                if (success) ExecutionResult(true, "Staged files.")
                else ExecutionResult(false, "Failed to stage one or more files.")
            }
            is AbstractCommand.Commit -> {
                val result = gitManager?.commit(command.message)
                result?.fold(
                    onSuccess = { ExecutionResult(true, "Committed successfully.", it) },
                    onFailure = { ExecutionResult(false, "Commit failed: ${it.message}") }
                ) ?: ExecutionResult(false, "GitManager not initialized.")
            }
            // --- Other commands can be implemented as needed ---
            else -> {
                logger.info("Executing command: ${command::class.simpleName} (Not fully implemented on Android)")
                ExecutionResult(true, "Command ${command::class.simpleName} executed with default success.")
            }
        }
    }
}


====================================================================
FILE: .\plugin_android_studio\build.gradle.kts
====================================================================

plugins {
    id("org.jetbrains.kotlin.jvm")
    id("org.jetbrains.intellij.platform")
}

repositories {
    mavenCentral()
}

// For a detailed guide, see:
// https://github.com/JetBrains/gradle-intellij-plugin/


dependencies {
    // Depend on the CLI module to get access to the core logic
    implementation(project(":cli"))
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions.jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
}





====================================================================
FILE: .\plugin_android_studio\src\main\resources\META-INF\plugin.xml
====================================================================
<idea-plugin>
    <id>com.hereliesaz.geministrator_plugin</id>
    <name>Geministrator</name>
    <version>1.0.0</version>
    <vendor>hereliesaz</vendor>
    <description><![CDATA[AI-driven development assistant to automate complex workflows.]]></description>
    <depends>com.intellij.modules.platform</depends>
    <depends>org.jetbrains.kotlin</depends>
    <depends>com.intellij.modules.vcs</depends>
    <depends>com.intellij.diff</depends>
    <extensions defaultExtensionNs="com.intellij">
        <toolWindow anchor="right" factoryClass="com.hereliesaz.geministrator_plugin.plugin.OrchestratorToolWindowFactory"
            icon="AllIcons.General.User"
            id="Geministrator" />
    </extensions>
    <actions>
        <action class="com.hereliesaz.geministrator_plugin.plugin.RunOrchestratorAction"
            description="Opens the Geministrator tool window."
            icon="AllIcons.Actions.Execute" id="Geministrator.Run"
            text="Run Geministrator">
            <add-to-group group-id="ToolsMenu" anchor="last"/>
        </action>
    </actions>
</idea-plugin>


====================================================================
FILE: .\plugin_android_studio\src\main\kotlin\com\hereliesaz\geministrator_plugin\adapter\AndroidStudioAdapter.kt
====================================================================
package com.hereliesaz.geministrator_plugin.adapter

import com.hereliesaz.geministrator.common.AbstractCommand
import com.hereliesaz.geministrator.common.ExecutionAdapter
import com.hereliesaz.geministrator.common.ExecutionResult
import com.hereliesaz.geministrator.common.ILogger
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.Messages
import com.intellij.openapi.vfs.VfsUtil
import java.io.File

class AndroidStudioAdapter(private val project: Project, private val logger: ILogger) : ExecutionAdapter {
    override fun execute(command: AbstractCommand, silent: Boolean): ExecutionResult {
        var result: ExecutionResult? = null
        ApplicationManager.getApplication().invokeAndWait {
            result = when (command) {
                is AbstractCommand.ReadFile -> {
                    try {
                        val file = VfsUtil.findFileByIoFile(File(project.basePath ?: "", command.path), true)
                        val content = file?.let { VfsUtil.loadText(it) } ?: ""
                        ExecutionResult(true, "Read file.", content)
                    } catch (e: Exception) {
                        ExecutionResult(false, "Failed to read file: ${e.message}")
                    }
                }

                is AbstractCommand.RequestCommitReview -> {
                    // This is a simplified version. A real implementation would be more complex. [cite: 869]
                    val userChoice = Messages.showYesNoDialog(
                        project,
                        "Approve changes for commit?\nMessage: ${command.proposedCommitMessage}",
                        "Final Review",
                        "Approve",
                        "Reject",
                        null
                    )
                    val decision = if (userChoice == Messages.YES) "APPROVE" else "REJECT"
                    ExecutionResult(true, "User chose '$decision'", decision)
                }

                // This is a simplified adapter. A full implementation would use the IntelliJ SDK [cite: 871]
                // for every single command (Git, file I/O, etc.) for maximum safety and integration. [cite: 871]
                else -> ExecutionResult(true, "Simulated execution of ${command::class.simpleName} in IDE", null)
            }
        }
        return result ?: ExecutionResult(false, "Adapter command failed to execute on EDT.")
    }
}


====================================================================
FILE: .\plugin_android_studio\src\main\kotlin\com\hereliesaz\geministrator_plugin\adapter\PluginConfigStorage.kt
====================================================================
package com.hereliesaz.geministrator_plugin.adapter

import com.hereliesaz.Geministrator.core.config.ConfigStorage
import com.intellij.ide.util.PropertiesComponent

class PluginConfigStorage : ConfigStorage {
    private val props = PropertiesComponent.getInstance()
    private val ID_API_KEY = "com.hereliesaz.GeminiOrchestrator.apiKey"
    private val ID_REVIEW_ENABLED = "com.hereliesaz.GeminiOrchestrator.reviewEnabled"
    private val ID_CONCURRENCY_LIMIT = "com.hereliesaz.GeminiOrchestrator.concurrencyLimit"
    private val ID_TOKEN_LIMIT = "com.hereliesaz.GeminiOrchestrator.tokenLimit"
    private val ID_MODEL_STRATEGIC = "com.hereliesaz.GeminiOrchestrator.modelStrategic"
    private val ID_MODEL_FLASH = "com.hereliesaz.GeminiOrchestrator.modelFlash"

    override fun saveApiKey(apiKey: String) = props.setValue(ID_API_KEY, apiKey)
    override fun loadApiKey(): String? = props.getValue(ID_API_KEY)
    override fun savePreCommitReview(enabled: Boolean) = props.setValue(ID_REVIEW_ENABLED, enabled, true)
    override fun loadPreCommitReview(): Boolean = props.getBoolean(ID_REVIEW_ENABLED, true)
    override fun saveConcurrencyLimit(limit: Int) = props.setValue(ID_CONCURRENCY_LIMIT, limit, 2)
    override fun loadConcurrencyLimit(): Int = props.getInt(ID_CONCURRENCY_LIMIT, 2)
    override fun saveTokenLimit(limit: Int) = props.setValue(ID_TOKEN_LIMIT, limit, 500000)
    override fun loadTokenLimit(): Int = props.getInt(ID_TOKEN_LIMIT, 500000)
    override fun saveModelName(type: String, name: String) = props.setValue(if (type == "strategic") ID_MODEL_STRATEGIC else ID_MODEL_FLASH, name)
    override fun loadModelName(type: String, default: String): String = props.getValue(if (type == "strategic") ID_MODEL_STRATEGIC else ID_MODEL_FLASH, default)
}


====================================================================
FILE: .\plugin_android_studio\src\main\kotlin\com\hereliesaz\geministrator_plugin\plugin\OrchestratorToolWindowFactory.kt
====================================================================
package com.hereliesaz.geministrator_plugin.plugin

import com.hereliesaz.geministrator.adapter.CliAdapter
import com.hereliesaz.geministrator.adapter.CliConfigStorage
import com.hereliesaz.geministrator.common.GeminiService
import com.hereliesaz.geministrator.common.ILogger
import com.hereliesaz.geministrator.common.PromptManager
import com.hereliesaz.geministrator.core.Orchestrator
import com.hereliesaz.geministrator_plugin.adapter.AndroidStudioAdapter
import com.hereliesaz.geministrator_plugin.adapter.PluginConfigStorage
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.Messages
import com.intellij.openapi.wm.ToolWindow
import com.intellij.openapi.wm.ToolWindowFactory
import com.intellij.ui.components.JBCheckBox
import com.intellij.ui.components.JBScrollPane
import com.intellij.ui.components.JBTextArea
import com.intellij.ui.content.ContentFactory
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.awt.BorderLayout
import java.awt.FlowLayout
import javax.swing.Box
import javax.swing.JButton
import javax.swing.JLabel
import javax.swing.JPanel
import javax.swing.JSpinner
import javax.swing.JSplitPane
import javax.swing.JTextArea
import javax.swing.SpinnerNumberModel
import javax.swing.SwingUtilities

class OrchestratorToolWindowFactory : ToolWindowFactory {
    private val coroutineScope = CoroutineScope(Dispatchers.Default)

    override fun createToolWindowContent(project: Project, toolWindow: ToolWindow) {
        val orchestratorPanel = OrchestratorPanel(project) // [cite: 873]
        val content = ContentFactory.getInstance().createContent(orchestratorPanel, "", false) // [cite: 873]
        toolWindow.contentManager.addContent(content) // [cite: 873]
    }

    inner class OrchestratorPanel(private val project: Project) : JPanel(BorderLayout()) {
        private val promptArea = JBTextArea(5, 50).apply {
            lineWrap = true
            wrapStyleWord = true
        }
        private val runButton = JButton("Run Workflow") // [cite: 874]
        private val outputArea = JTextArea().apply {
            isEditable = false
            font = font.deriveFont(12f)
        }
        private val configStorage = PluginConfigStorage()
        private val logger = ProgressLogger(outputArea)
        private val reviewCheckbox =
            JBCheckBox("Require final review before commit", configStorage.loadPreCommitReview())
        private val concurrencyLabel = JLabel("Max Parallel Tasks:") // [cite: 875]
        private val concurrencySpinner =
            JSpinner(SpinnerNumberModel(configStorage.loadConcurrencyLimit(), 1, 16, 1)) // [cite: 875]
        private val tokenLimitLabel = JLabel("Token Limit:") // [cite: 875]
        private val tokenLimitSpinner =
            JSpinner(SpinnerNumberModel(configStorage.loadTokenLimit(), 10000, 2000000, 10000)) // [cite: 875]

        init {
            val settingsPanel = JPanel(FlowLayout(FlowLayout.LEFT))
            settingsPanel.add(reviewCheckbox)
            settingsPanel.add(Box.createHorizontalStrut(10))
            settingsPanel.add(concurrencyLabel)
            settingsPanel.add(concurrencySpinner)
            settingsPanel.add(Box.createHorizontalStrut(10)) // [cite: 877]
            settingsPanel.add(tokenLimitLabel)
            settingsPanel.add(tokenLimitSpinner)

            val buttonPanel = JPanel(BorderLayout())
            buttonPanel.add(runButton, BorderLayout.CENTER)
            buttonPanel.add(settingsPanel, BorderLayout.SOUTH)

            val topPanel = JPanel(BorderLayout())
            topPanel.add(JBScrollPane(promptArea), BorderLayout.CENTER)
            topPanel.add(buttonPanel, BorderLayout.SOUTH) // [cite: 878]

            val mainPanel = JPanel(BorderLayout())
            mainPanel.add(topPanel, BorderLayout.NORTH)
            mainPanel.add(JBScrollPane(outputArea), BorderLayout.CENTER)

            val splitPane = JSplitPane(JSplitPane.VERTICAL_SPLIT, mainPanel, JScrollPane(JTextArea("")))
            splitPane.resizeWeight = 0.7

            add(splitPane, BorderLayout.CENTER)

            runButton.addActionListener {
                coroutineScope.launch { runWorkflow(promptArea.text) }
            }
            reviewCheckbox.addActionListener { configStorage.savePreCommitReview(reviewCheckbox.isSelected) } // [cite: 880]
            concurrencySpinner.addChangeListener { configStorage.saveConcurrencyLimit(concurrencySpinner.value as Int) } // [cite: 880]
            tokenLimitSpinner.addChangeListener { configStorage.saveTokenLimit(tokenLimitSpinner.value as Int) } // [cite: 880]

            if (configStorage.loadApiKey().isNullOrBlank()) {
                showOnboardingWizard()
            }
        }

        private fun showOnboardingWizard() {
            SwingUtilities.invokeLater {
                Messages.showMessageDialog(
                    project,
                    "Welcome to Geministrator!\nThis tool requires a Gemini API Key to function.\nPlease enter your key to continue.",
                    "Welcome",
                    Messages.getInformationIcon()
                )
                coroutineScope.launch { getAndValidateApiKey() }
            }
        }

        private suspend fun runWorkflow(prompt: String) {
            if (prompt.isBlank()) return
            withContext(Dispatchers.Main) {
                outputArea.text = ""
                runButton.isEnabled = false
            }

            // The adapter for the plugin UI
            val adapter = AndroidStudioAdapter(project, logger)

            // Since the CLI module contains the core logic, we need its config and prompt manager
            val cliConfig = CliConfigStorage()
            val promptManager = PromptManager(cliConfig.getConfigDirectory())

            // Create the GeminiService with all its required arguments
            val geminiService = createGeminiService(cliConfig, logger, CliAdapter(cliConfig, logger))

            if (geminiService == null) {
                logger.error("Could not create Gemini Service. Check authentication.")
                withContext(Dispatchers.Main) { runButton.isEnabled = true }
                return
            }

            // Create the orchestrator with all its required arguments
            val orchestrator = Orchestrator(adapter, logger, cliConfig, promptManager, geminiService)

            try {
                // For now, projectType is hardcoded. This could be a dropdown in the UI later.
                orchestrator.run(prompt, project.basePath ?: ".", "IDE Plugin Task", null)
            } catch (e: Exception) {
                logger.error("--- A critical error occurred ---", e)
            } finally {
                logger.info("--- Workflow Finished ---")
                withContext(Dispatchers.Main) { runButton.isEnabled = true }
            }
        }

        private suspend fun getAndValidateApiKey(): String? {
            var apiKey = configStorage.loadApiKey()
            while (true) {
                if (!apiKey.isNullOrBlank()) {
                    val serviceForValidation = GeminiService("apikey", apiKey, logger, configStorage, "", "", null, null)
                    if (serviceForValidation.validateApiKey(apiKey)) {
                        return apiKey
                    }
                    logger.error("Your saved API key is no longer valid. Please enter a new one.")
                }
                apiKey = withContext(Dispatchers.Main) {
                    Messages.showInputDialog(
                        project,
                        "Please enter your Gemini API Key:",
                        "API Key Required",
                        Messages.getQuestionIcon()
                    )
                }
                if (apiKey.isNullOrBlank()) return null
                configStorage.saveApiKey(apiKey) // Save the key to be validated
            }
        }
    }
}


====================================================================
FILE: .\plugin_android_studio\src\main\kotlin\com\hereliesaz\geministrator_plugin\plugin\RunOrchestratorAction.kt
====================================================================
package com.hereliesaz.geministrator_plugin.plugin

import com.intellij.openapi.actionSystem.AnAction
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.wm.ToolWindowManager

class RunOrchestratorAction : AnAction() {
    override fun actionPerformed(e: AnActionEvent) {
        val project = e.project ?: return
        val toolWindow = ToolWindowManager.getInstance(project).getToolWindow("Geministrator")
        toolWindow?.show()
    }
}


====================================================================
FILE: .\plugin_android_studio\src\main\kotlin\com\hereliesaz\geministrator_plugin\plugin\ProgressLogger.kt
====================================================================
package com.hereliesaz.geministrator_plugin.plugin

import com.hereliesaz.geministrator.common.ILogger
import com.intellij.openapi.application.ApplicationManager
import javax.swing.JTextArea

class ProgressLogger(private val outputArea: JTextArea) : ILogger {
    private fun log(message: String) {
        ApplicationManager.getApplication().invokeLater {
            outputArea.append("$message\n")
            outputArea.caretPosition = outputArea.document.length
        }
    }

    override fun info(message: String) {
        log("[INFO] $message")
    }

    override fun error(message: String, e: Throwable?) {
        val fullMessage = if (e != null) "$message: ${e.message}" else message
        log("[ERROR] $fullMessage")
    }

    override fun interactive(message: String) {
        log("[USER] $message")
    }

    override fun prompt(message: String): String? {
        // Cannot prompt from a non-interactive logger in the UI
        // This could be implemented with a dialog box if needed
        interactive(message)
        return null
    }
}


====================================================================
FILE: .\plugin_vscode\.vscodeignore
====================================================================


====================================================================
FILE: .\plugin_vscode\package.json
====================================================================
{
  "name": "geministrator",
  "displayName": "Geministrator",
  "description": "An AI-powered development assistant built on a team of collaborative agents.",
  "version": "1.1.0",
  "publisher": "hereliesaz",
  "engines": {
    "vscode": "^1.80.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onCommand:geministrator.start"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "geministrator.start",
        "title": "Start Geministrator",
        "category": "Geministrator"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./"
  },
  "devDependencies": {
    "@types/vscode": "^1.80.0",
    "@types/node": "18.x",
    "typescript": "^5.0.0"
  }
}


====================================================================
FILE: .\plugin_vscode\tsconfig.json
====================================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2020",
    "outDir": "out",
    "lib": [
      "ES2020"
    ],
    "sourceMap": true,
    "rootDir": "src",
    "strict": true
  },
  "exclude": [
    "node_modules",
    ".vscode-test"
  ]
}



====================================================================
FILE: .\plugin_vscode\build.gradle.kts
====================================================================
plugins {
    base
}

// A beautiful crime against nature. We're using Gradle to wrangle a Node.js project.
// Why? Because we can. Because the unity of the build system is a goal in itself,
// however perverse the path to achieving it may be.

description = "Geministrator VSCode Plugin"

// Define paths for the Node project within the Gradle module
val nodeDir = project.projectDir
val vsixDir = layout.buildDirectory.dir("vsix")

// Task to install npm dependencies from package.json
val npmInstall by tasks.registering(Exec::class) {
    group = "VSCode"
    description = "Install Node.js dependencies."
    workingDir = nodeDir
    commandLine("npm", "install")

    inputs.file(file("package.json"))
    inputs.file(file("package-lock.json"))
    outputs.dir(file("node_modules"))
}

// Task to run the VSCode extension packager (vsce)
val vscePackage by tasks.registering(Exec::class) {
    dependsOn(npmInstall)
    group = "VSCode"
    description = "Package the extension into a .vsix file."
    workingDir = nodeDir
    // Assumes vsce is a dev dependency, accessed via npx
    commandLine("npx", "vsce", "package", "--out", vsixDir.get().asFile.absolutePath)

    inputs.dir(file("src"))
    inputs.file(file("package.json"))
    outputs.dir(vsixDir)
}

// The main 'build' task for this module creates the .vsix package
tasks.named("build") {
    dependsOn(vscePackage)
}

// A 'clean' task to remove all generated files
tasks.named("clean", Delete::class) {
    delete(vsixDir)
    delete(file("node_modules"))
    delete(file("out"))
}


====================================================================
FILE: .\plugin_vscode\src\extension.ts
====================================================================
import * as vscode from 'vscode';
import { spawn, ChildProcess } from 'child_process';

let orchestratorPanel: vscode.WebviewPanel | undefined;
let orchestratorProcess: ChildProcess | undefined;

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('geministrator.start', () => {
            if (orchestratorPanel) {
                orchestratorPanel.reveal(vscode.ViewColumn.Two);
                return;
            }

            orchestratorPanel = vscode.window.createWebviewPanel(
                'geministrator',
                'Geministrator',
                vscode.ViewColumn.Two,
                {
                    enableScripts: true,
                    localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media')]
                }
            );

            orchestratorPanel.webview.html = getWebviewContent();

            orchestratorPanel.onDidDispose(() => {
                orchestratorPanel = undefined;
                if (orchestratorProcess) {
                    orchestratorProcess.kill();
                    orchestratorProcess = undefined;
                }
            }, null, context.subscriptions);

            orchestratorPanel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'runWorkflow':
                            runCliProcess(message.text);
                            return;
                        case 'sendToCli':
                            if (orchestratorProcess && orchestratorProcess.stdin) {
                                orchestratorProcess.stdin.write(`${message.text}\n`);
                            }
                            return;
                    }
                },
                undefined,
                context.subscriptions
            );
        })
    );
}

function runCliProcess(prompt: string) {
    if (orchestratorProcess) {
        orchestratorProcess.kill();
    }

    // Call the CLI command directly, assuming it is on the system's PATH.
    // This is more robust than a hardcoded relative path.
    const command = 'geministrator';
    const args = ['run', prompt];

    orchestratorProcess = spawn(command, args);

    orchestratorProcess.stdout?.on('data', (data: Buffer) => {
        const message = data.toString();
        orchestratorPanel?.webview.postMessage({ command: 'log', text: message });
    });

    orchestratorProcess.stderr?.on('data', (data: Buffer) => {
        const message = data.toString();
        orchestratorPanel?.webview.postMessage({ command: 'log', text: `ERROR: ${message}` });
    });

    orchestratorProcess.on('close', (code) => {
        orchestratorPanel?.webview.postMessage({ command: 'log', text: `\n--- Process finished with exit code ${code} ---` });
        orchestratorProcess = undefined;
    });

    orchestratorProcess.on('error', (err) => {
        orchestratorPanel?.webview.postMessage({ command: 'log', text: `\n--- FAILED TO START PROCESS ---\nIs 'geministrator' installed and in your system's PATH?\nError: ${err.message}` });
        orchestratorProcess = undefined;
    });
}

function getWebviewContent(): string {
    return `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Geministrator</title>
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
                #output { white-space: pre-wrap; background-color: #222; color: #eee; padding: 10px; font-family: monospace; height: 70vh; overflow-y: scroll; border-radius: 5px; }
                textarea { width: 95%; margin-bottom: 10px; }
                button { padding: 5px 10px; }
            </style>
        </head>
        <body>
            <h1>Geministrator</h1>
            <textarea id="prompt" rows="4" placeholder="Enter your high-level task..."></textarea>
            <br>
            <button id="run-button">Run Workflow</button>

            <h3>Output Log</h3>
            <div id="output">Welcome! Enter a prompt and click "Run Workflow" to begin.</div>

            <script>
                const vscode = acquireVsCodeApi();
                const runButton = document.getElementById('run-button');
                const promptArea = document.getElementById('prompt');
                const outputArea = document.getElementById('output');

                runButton.addEventListener('click', () => {
                    const text = promptArea.value;
                    if (text) {
                        outputArea.textContent = ''; // Clear previous output
                        vscode.postMessage({ command: 'runWorkflow', text: text });
                    }
                });

                window.addEventListener('message', event => {
                    const message = event.data;
                    switch (message.command) {
                        case 'log':
                            outputArea.textContent += message.text;
                            outputArea.scrollTop = outputArea.scrollHeight; // Auto-scroll
                            break;
                    }
                });
            </script>
        </body>
        </html>
    `;
}

export function deactivate() {
    if (orchestratorProcess) {
        orchestratorProcess.kill();
    }
}


